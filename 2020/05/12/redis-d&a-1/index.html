<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.1/css/all.min.css" integrity="sha256-Z1K5uhUaJXA7Ll0XrZ/0JhX4lAtZFpT6jkKrEDT0drU=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"mercuriussss.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.14.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="一、简单动态字符串1、SDS的数据结构与示例​		Redis 是用 C 语言开发的一个高性能缓存框架，支持五种基本的数据结构，这些数据结构的底层也是由 C 语言实现的。 ​		大多数情况下，Redis 用于存储字符串的结构为简单动态字符串（Simple Dynamic String），简称 SDS，其底层实现如下所示。 12345struct sdshdr &amp;#123;    int len;">
<meta property="og:type" content="article">
<meta property="og:title" content="一、Redis底层数据结构">
<meta property="og:url" content="https://mercuriussss.github.io/2020/05/12/redis-d&a-1/index.html">
<meta property="og:site_name" content="量子猫">
<meta property="og:description" content="一、简单动态字符串1、SDS的数据结构与示例​		Redis 是用 C 语言开发的一个高性能缓存框架，支持五种基本的数据结构，这些数据结构的底层也是由 C 语言实现的。 ​		大多数情况下，Redis 用于存储字符串的结构为简单动态字符串（Simple Dynamic String），简称 SDS，其底层实现如下所示。 12345struct sdshdr &amp;#123;    int len;">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://mercuriussss.github.io/2020/05/12/redis-d&a-1/image-20210401100415782.png">
<meta property="og:image" content="https://mercuriussss.github.io/2020/05/12/redis-d&a-1/image-2.png">
<meta property="og:image" content="https://mercuriussss.github.io/2020/05/12/redis-d&a-1/image-3.png">
<meta property="og:image" content="https://mercuriussss.github.io/2020/05/12/redis-d&a-1/image-4.png">
<meta property="og:image" content="https://mercuriussss.github.io/2020/05/12/redis-d&a-1/image-5.png">
<meta property="og:image" content="https://mercuriussss.github.io/2020/05/12/redis-d&a-1/image-6.jpg">
<meta property="og:image" content="https://mercuriussss.github.io/2020/05/12/redis-d&a-1/image-7.png">
<meta property="og:image" content="https://mercuriussss.github.io/2020/05/12/redis-d&a-1/image-8.png">
<meta property="og:image" content="https://mercuriussss.github.io/2020/05/12/redis-d&a-1/image-9.png">
<meta property="og:image" content="https://mercuriussss.github.io/2020/05/12/redis-d&a-1/image-10.png">
<meta property="og:image" content="https://mercuriussss.github.io/2020/05/12/redis-d&a-1/image-11.png">
<meta property="article:published_time" content="2020-05-12T13:05:51.000Z">
<meta property="article:modified_time" content="2023-03-10T11:10:04.818Z">
<meta property="article:author" content="量子猫">
<meta property="article:tag" content="Redis">
<meta property="article:tag" content="Redis设计与实现">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://mercuriussss.github.io/2020/05/12/redis-d&a-1/image-20210401100415782.png">


<link rel="canonical" href="https://mercuriussss.github.io/2020/05/12/redis-d&a-1/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://mercuriussss.github.io/2020/05/12/redis-d&a-1/","path":"2020/05/12/redis-d&a-1/","title":"一、Redis底层数据结构"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>一、Redis底层数据结构 | 量子猫</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">量子猫</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">我们所度过的每一个日常,也许就是连续发生的奇迹</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E7%AE%80%E5%8D%95%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-text">一、简单动态字符串</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81SDS%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%A4%BA%E4%BE%8B"><span class="nav-text">1、SDS的数据结构与示例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81SDS%E8%B7%9FC%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%88%E4%BC%98%E5%8A%BF%EF%BC%89"><span class="nav-text">2、SDS跟C字符串的区别（优势）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E5%B8%B8%E6%95%B0%E5%A4%8D%E6%9D%82%E5%BA%A6%E8%8E%B7%E5%8F%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%95%BF%E5%BA%A6"><span class="nav-text">（1）常数复杂度获取字符串长度</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%EF%BC%882%EF%BC%89%E6%9D%9C%E7%BB%9D%E7%BC%93%E5%AD%98%E5%8C%BA%E6%BA%A2%E5%87%BA"><span class="nav-text">（2）杜绝缓存区溢出</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%EF%BC%883%EF%BC%89%E5%87%8F%E5%B0%91%E4%BF%AE%E6%94%B9%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%97%B6%E7%9A%84%E5%86%85%E5%AD%98%E9%87%8D%E5%88%86%E9%85%8D%E6%AC%A1%E6%95%B0"><span class="nav-text">（3）减少修改字符串时的内存重分配次数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%EF%BC%884%EF%BC%89%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8"><span class="nav-text">（4）二进制安全</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81SDS%E5%85%BC%E5%AE%B9%E9%83%A8%E5%88%86C%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0"><span class="nav-text">3、SDS兼容部分C字符串函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E3%80%81%E9%93%BE%E8%A1%A8"><span class="nav-text">二、链表</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E9%93%BE%E8%A1%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%A4%BA%E4%BE%8B"><span class="nav-text">1、链表的数据结构与示例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E9%93%BE%E8%A1%A8%E7%9A%84%E7%89%B9%E6%80%A7"><span class="nav-text">2、链表的特性</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%89%E3%80%81%E5%AD%97%E5%85%B8"><span class="nav-text">三、字典</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E5%AD%97%E5%85%B8%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%A4%BA%E4%BE%8B"><span class="nav-text">1、字典的数据结构与示例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95%E4%B8%8E%E9%94%AE%E5%86%B2%E7%AA%81"><span class="nav-text">2、哈希算法与键冲突</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81%E6%B8%90%E8%BF%9B%E5%BC%8Frehash"><span class="nav-text">3、渐进式rehash</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%EF%BC%881%EF%BC%89rehash-%E5%AE%9A%E4%B9%89"><span class="nav-text">（1）rehash 定义</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%EF%BC%882%EF%BC%89%E8%B4%9F%E8%BD%BD%E5%9B%A0%E5%AD%90%E7%9A%84%E8%AE%A1%E7%AE%97%E5%85%AC%E5%BC%8F"><span class="nav-text">（2）负载因子的计算公式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%EF%BC%883%EF%BC%89rehash-%E8%A7%A6%E5%8F%91%E6%9D%A1%E4%BB%B6"><span class="nav-text">（3）rehash 触发条件</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%EF%BC%884%EF%BC%89rehash-%E8%AF%A6%E7%BB%86%E6%AD%A5%E9%AA%A4"><span class="nav-text">（4）rehash 详细步骤</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%EF%BC%885%EF%BC%89rehash-%E6%9C%9F%E9%97%B4%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="nav-text">（5）rehash 期间的操作</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%9B%E3%80%81%E8%B7%B3%E8%B7%83%E8%A1%A8"><span class="nav-text">四、跳跃表</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E8%B7%B3%E8%B7%83%E8%A1%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%A4%BA%E4%BE%8B"><span class="nav-text">1、跳跃表的数据结构与示例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E8%B7%B3%E8%B7%83%E8%A1%A8%E7%9A%84%E5%A2%9E%E5%88%A0%E6%9F%A5"><span class="nav-text">2、跳跃表的增删查</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%94%E3%80%81%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88"><span class="nav-text">五、整数集合</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%A4%BA%E4%BE%8B"><span class="nav-text">1、整数集合的数据结构与示例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88%E7%9A%84%E5%8D%87%E7%BA%A7%E5%92%8C%E9%99%8D%E7%BA%A7"><span class="nav-text">2、整数集合的升级和降级</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E5%8D%87%E7%BA%A7%E5%92%8C%E9%99%8D%E7%BA%A7%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-text">（1）升级和降级的定义</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%EF%BC%882%EF%BC%89%E5%8D%87%E7%BA%A7%E7%9A%84%E6%AD%A5%E9%AA%A4"><span class="nav-text">（2）升级的步骤</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88%E5%8D%87%E7%BA%A7%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="nav-text">3、整数集合升级的好处</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E6%8F%90%E9%AB%98%E7%81%B5%E6%B4%BB%E6%80%A7"><span class="nav-text">（1）提高灵活性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%EF%BC%882%EF%BC%89%E8%8A%82%E7%BA%A6%E5%86%85%E5%AD%98"><span class="nav-text">（2）节约内存</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%AD%E3%80%81%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8"><span class="nav-text">六、压缩列表</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-text">1、压缩列表的数据结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E8%BF%9E%E9%94%81%E6%9B%B4%E6%96%B0"><span class="nav-text">2、连锁更新</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="量子猫"
      src="/images/xz.jpg">
  <p class="site-author-name" itemprop="name">量子猫</p>
  <div class="site-description" itemprop="description">Stay Hungry, Stay Foolish</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">16</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://mercuriussss.github.io/2020/05/12/redis-d&a-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/xz.jpg">
      <meta itemprop="name" content="量子猫">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="量子猫">
      <meta itemprop="description" content="Stay Hungry, Stay Foolish">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="一、Redis底层数据结构 | 量子猫">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          一、Redis底层数据结构
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-05-12 21:05:51" itemprop="dateCreated datePublished" datetime="2020-05-12T21:05:51+08:00">2020-05-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-03-10 19:10:04" itemprop="dateModified" datetime="2023-03-10T19:10:04+08:00">2023-03-10</time>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>9.4k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>23 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h3 id="一、简单动态字符串"><a href="#一、简单动态字符串" class="headerlink" title="一、简单动态字符串"></a>一、简单动态字符串</h3><h4 id="1、SDS的数据结构与示例"><a href="#1、SDS的数据结构与示例" class="headerlink" title="1、SDS的数据结构与示例"></a>1、SDS的数据结构与示例</h4><p>​		Redis 是用 C 语言开发的一个高性能缓存框架，支持五种基本的数据结构，这些数据结构的底层也是由 C 语言实现的。</p>
<p>​		大多数情况下，Redis 用于存储字符串的结构为简单动态字符串（Simple Dynamic String），简称 SDS，其底层实现如下所示。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> len;     <span class="comment">//记录buf数组已使用字节数量，即字符串长度</span></span><br><span class="line">    <span class="type">int</span> <span class="built_in">free</span>;    <span class="comment">//记录buf数组未使用字节数量，即剩余空间</span></span><br><span class="line">    <span class="type">char</span> buf[];  <span class="comment">//字节数组，用于保存字符串</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/12/redis-d&a-1/image-20210401100415782.png" alt="image-20210401100415782"></p>
<div align="center" style="font-size:12px">图1-1 SDS数据结构示例图</div>

<h4 id="2、SDS跟C字符串的区别（优势）"><a href="#2、SDS跟C字符串的区别（优势）" class="headerlink" title="2、SDS跟C字符串的区别（优势）"></a>2、SDS跟C字符串的区别（优势）</h4><h5 id="（1）常数复杂度获取字符串长度"><a href="#（1）常数复杂度获取字符串长度" class="headerlink" title="（1）常数复杂度获取字符串长度"></a>（1）常数复杂度获取字符串长度</h5><p>​		C字符串获取长度时，需要遍历整个字符串，其时间复杂度为O(N)</p>
<p>​		SDS则本身len属性记录了长度，获取长度的时间复杂度仅为O(1)</p>
<h5 id="（2）杜绝缓存区溢出"><a href="#（2）杜绝缓存区溢出" class="headerlink" title="（2）杜绝缓存区溢出"></a>（2）杜绝缓存区溢出</h5><p>​		C字符串如果在追加字符前未给该字符串分配足够多的内存空间，那么该字符串的数据可能会溢出、污染到相邻空间的内存数据。</p>
<table>
<thead>
<tr>
<th align="center">str 1</th>
<th align="center">str 2</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Redis</td>
<td align="center">MongoDB</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="center">str 1</th>
<th align="center">str 2</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Redis</td>
<td align="center">Cluster</td>
</tr>
</tbody></table>
<p>​		例如 str1 和 str2 在内存中是紧挨着的，然后 str1 使用 strcat 方法追加内容”Cluster”，那么 str1 的数据将溢出到 str2 的内存空间里，在 str2 不知情的情况下将”MongoDB”修改成了”Cluster”，这是 <strong>C 语言的缓冲区溢出问题，即 API 的调用是不安全的</strong>。</p>
<p>​		SDS 则没有该问题的存在，在对字符串进行拼接操作时，它会先检查字符串的长度是否足够，即 free 的空间是否足够，若不足则会先扩展空间再进行拼接操作</p>
<h5 id="（3）减少修改字符串时的内存重分配次数"><a href="#（3）减少修改字符串时的内存重分配次数" class="headerlink" title="（3）减少修改字符串时的内存重分配次数"></a>（3）减少修改字符串时的内存重分配次数</h5><p>​		C 字符串在进行<strong>增长字符串</strong>操作时，若没在操作前通过内存重分配来<strong>扩展空间</strong>，那就有可能产生<strong>缓冲区溢出</strong>的问题。</p>
<p>​		C 字符串在进行<strong>缩短字符串</strong>操作时，若没在操作前通过内存重分配来<strong>释放空间</strong>，那就有可能产生<strong>内存泄漏</strong>的问题。</p>
<p>​		Redis 当然不可能每次操作都进行内存重分配，那样会相当影响性能，于是 SDS 使用空间预分配和惰性空间释放两种策略来进行优化。</p>
<ul>
<li><p>内存预分配</p>
<ul>
<li><p>当 SDS 修改后的长度（即 len 属性值）小于 1M 时，程序除了为其分配修改后的长度的内存空间，还会为其分配同等长度的未使用空间。</p>
<p>例如，若 SDS 的 len 修改后变成 13 字节，那么程序会为其分配 13 字节的未使用空间，最终 buf 数组的长度为 13 + 13 + 1 &#x3D; 27 字节</p>
</li>
<li><p>当 SDS 修改后的长度（即 len 属性值）大于 1M 时，程序除了分配应有的空间外，还会为其分配 1M 的未使用空间。</p>
<p>例如，若 SDS 的 len 修改后变成 30M，那么程序会分配 1M 的未使用空间，最终 buf 数组的长度为 30M + 1M + 1 byte</p>
</li>
</ul>
</li>
<li><p>惰性空间释放</p>
<p>定义：当 SDS 的 API 需要缩短字符串时，程序不会立即用内存重分配去回收空间，而是用 free 属性将这部分长度记录起来，等待再次使用。</p>
<p>优点：这样做能避免缩短字符串带来的内存重分配操作，并为之后可能有的增长操作提供优化。</p>
<p>​			同时，SDS 也提供了相应的 API 可以在有需要时释放 SDS 的未使用空间，所以不必担心惰性空间策略的内存浪费问题。</p>
</li>
</ul>
<h5 id="（4）二进制安全"><a href="#（4）二进制安全" class="headerlink" title="（4）二进制安全"></a>（4）二进制安全</h5><ul>
<li><p>C 字符串中的字符必须符合某种编码（例如 ASCII ），并且除末尾外中间不能包含空字符，C 字符串只能用来保存文本数据。</p>
</li>
<li><p>Redis 的 SDS 不仅可以保存文本数据，还可以保存任意格式的二进制数据，例如图片、音频、视频、压缩文件等</p>
<p>Redis 的 SDS API 采用了二进制的处理方式将数据保存到 buf 数组中，buf 数组保存的不是字符，而是一系列二进制数据，因此它也被称作<strong>字节数组</strong>。</p>
</li>
</ul>
<h4 id="3、SDS兼容部分C字符串函数"><a href="#3、SDS兼容部分C字符串函数" class="headerlink" title="3、SDS兼容部分C字符串函数"></a>3、SDS兼容部分C字符串函数</h4><p>​		虽然 SDS 的 API 都是二进制安全的，但它们同样遵循着 C 字符串以空字符结尾的惯例，这是为了让 SDS 可以重用一部分 &lt;string.h&gt; 函数，避免重复造轮子。</p>
<h3 id="二、链表"><a href="#二、链表" class="headerlink" title="二、链表"></a>二、链表</h3><h4 id="1、链表的数据结构与示例"><a href="#1、链表的数据结构与示例" class="headerlink" title="1、链表的数据结构与示例"></a>1、链表的数据结构与示例</h4><p>​		链表在 Redis 中的应用相当广泛，例如列表键的底层实现之一就是链表，并且<strong>发布与订阅、慢查询、监视器</strong>等功能也用到了列表。</p>
<p>​		以下为 Redis 的链表数据结构定义。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span> &#123;</span></span><br><span class="line">    listNode * head; <span class="comment">// 表头节点</span></span><br><span class="line">    listNode * tail; <span class="comment">// 表尾节点</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> len; <span class="comment">// 链表所包含的节点数量</span></span><br><span class="line">    <span class="type">void</span> *(*dup)(<span class="type">void</span> *ptr); <span class="comment">// 节点值复制函数</span></span><br><span class="line">    <span class="type">void</span> (*<span class="built_in">free</span>)(<span class="type">void</span> *ptr); <span class="comment">// 节点值释放函数</span></span><br><span class="line">    <span class="type">int</span> (*match)(<span class="type">void</span> *ptr,<span class="type">void</span> *key); <span class="comment">// 节点值对比函数</span></span><br><span class="line">&#125; <span class="built_in">list</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> * <span class="title">prev</span>;</span> <span class="comment">// 前置节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> * <span class="title">next</span>;</span> <span class="comment">// 后置节点</span></span><br><span class="line">    <span class="type">void</span> * value; <span class="comment">//节点的值</span></span><br><span class="line">&#125;listNode;</span><br></pre></td></tr></table></figure>

<p>​		下图为一个 list 结构和三个 listNode 结构所组成的链表</p>
<p><img src="/2020/05/12/redis-d&a-1/image-2.png" alt="image-2"></p>
<div align="center" style="font-size:12px">图1-2 链表数据结构示例图</div>

<h4 id="2、链表的特性"><a href="#2、链表的特性" class="headerlink" title="2、链表的特性"></a>2、链表的特性</h4><ul>
<li>双端：链表结点带有 prev 和 next 指针</li>
<li>无环：头结点的 prev 和尾结点的 next ，两个指针都指向 NULL</li>
<li>带头尾指针： list 结构中含有头尾指针，可直接获取</li>
<li>带链表长度计数器： list 结构中含有 len 属性，保存着整个链表的数量</li>
<li>多态：表节点使用void*指针来保存节点值，并且可以通过list结构的dup、free、match三个属性为节点值设置类型特定函数，所以链表可以用于保存各种不同类型的值</li>
</ul>
<h3 id="三、字典"><a href="#三、字典" class="headerlink" title="三、字典"></a>三、字典</h3><h4 id="1、字典的数据结构与示例"><a href="#1、字典的数据结构与示例" class="headerlink" title="1、字典的数据结构与示例"></a>1、字典的数据结构与示例</h4><p>​		字典（dict），又称为符号表、关联数组或映射，底层实现为哈希表，是一种用于保存键值对的抽象数据结构。</p>
<p>​		Redis 的数据库使用了字典作为底层实现，对数据库的增删查改操作都是构建在对字典的操作之上，同时字典也是哈希键的底层实现之一。</p>
<p>​		以下为 Redis 的字典数据结构定义，其中 type 和 privdata 属性是针对不同类型的键值对，为创建多态字典而设置的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字典</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></span><br><span class="line">    dictType *type;<span class="comment">//类型特定函数</span></span><br><span class="line">    <span class="type">void</span> *privdata;<span class="comment">//私有数据</span></span><br><span class="line">    dictht ht[<span class="number">2</span>];<span class="comment">//哈希表</span></span><br><span class="line">    <span class="type">int</span> rehashidx; <span class="comment">// rehash索引，当rehash不在进行时，值为-1</span></span><br><span class="line">&#125; dict;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型特定函数</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictType</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="title function_">int</span> <span class="params">(*hashFunction)</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *key)</span>;<span class="comment">//计算哈希值的函数</span></span><br><span class="line">    <span class="type">void</span> *(*keyDup)(<span class="type">void</span> *privdata, <span class="type">const</span> <span class="type">void</span> *key);<span class="comment">//复制键的函数</span></span><br><span class="line">    <span class="type">void</span> *(*valDup)(<span class="type">void</span> *privdata, <span class="type">const</span> <span class="type">void</span> *obj);<span class="comment">//复制值的函数</span></span><br><span class="line">    <span class="type">int</span> (*keyCompare)(<span class="type">void</span> *privdata, <span class="type">const</span> <span class="type">void</span> *key1, <span class="type">const</span> <span class="type">void</span> *key2);<span class="comment">//对比键的函数</span></span><br><span class="line">    <span class="type">void</span> (*keyDestructor)(<span class="type">void</span> *privdata, <span class="type">void</span> *key);<span class="comment">//销毁键的函数</span></span><br><span class="line">    <span class="type">void</span> (*valDestructor)(<span class="type">void</span> *privdata, <span class="type">void</span> *obj);<span class="comment">//销毁值的函数</span></span><br><span class="line">&#125; dictType;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 哈希表</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span> &#123;</span></span><br><span class="line">    dictEntry **table;&#123;<span class="comment">//哈希表数组</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> size;<span class="comment">//哈希表大小</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> sizemask;<span class="comment">//哈希表大小掩码，用于计算索引值，总是等于size-1</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> used;<span class="comment">//该哈希表已有节点的数量</span></span><br><span class="line">&#125; dictht;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 哈希表节点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span></span><br><span class="line">    <span class="type">void</span> *key;<span class="comment">//键</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span>&#123;</span> <span class="comment">//值</span></span><br><span class="line">        <span class="type">void</span> *val;</span><br><span class="line">        uint64_tu64;</span><br><span class="line">        int64_ts64;</span><br><span class="line">    &#125; v;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span><span class="comment">//指向下个哈希表节点，形成链表</span></span><br><span class="line">&#125; dictEntry;</span><br></pre></td></tr></table></figure>
<p>​		下图为一个普通状态下（没有进行rehash）的字典。</p>
<p>​		<img src="/2020/05/12/redis-d&a-1/image-3.png" alt="image-3"></p>
<div align="center" style="font-size:12px">图1-3 字典数据结构示例图</div>

<h4 id="2、哈希算法与键冲突"><a href="#2、哈希算法与键冲突" class="headerlink" title="2、哈希算法与键冲突"></a>2、哈希算法与键冲突</h4><p>​		当 Redis 要将一个新的键值对添加到字典中时，程序要先根据key计算出哈希值和索引值，目前 Redis 用于计算哈希值的算法为 <strong>MurmurHash2 一致性哈希算法</strong>，其优点是计算速度快、随机分布性良好，而 MurmurHash 算法最新版本为 MurmurHash3 。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#使用字典设置的哈希函数，计算键key的哈希值 </span><br><span class="line">hash = dict-＞type-＞hashFunction(key); </span><br><span class="line"></span><br><span class="line">#使用哈希表的sizemask属性和哈希值，计算出索引值 </span><br><span class="line">#根据情况不同，ht[x]可以是ht[<span class="number">0</span>]或者ht[<span class="number">1</span>] </span><br><span class="line">index = hash &amp; dict-＞ht[x].sizemask;</span><br></pre></td></tr></table></figure>

<p>​		在计算完哈希值和索引值后，程序会将节点放到对应的索引位置上，如果遇到键冲突则使用链地址法来解决，并且从速度考虑，每次添加新节点都会添加到表头的位置，即头插法。</p>
<p>​		如下图所示，新增的键值对k2会添加到k1前面。</p>
<p><img src="/2020/05/12/redis-d&a-1/image-4.png" alt="image-4"></p>
<div align="center" style="font-size:12px">图1-4 链地址法解决键冲突</div>

<h4 id="3、渐进式rehash"><a href="#3、渐进式rehash" class="headerlink" title="3、渐进式rehash"></a>3、渐进式rehash</h4><h5 id="（1）rehash-定义"><a href="#（1）rehash-定义" class="headerlink" title="（1）rehash 定义"></a>（1）rehash 定义</h5><p>​		为了让哈希表的负载因子维持在一个合理的范围内，当哈希表保存的键值对数量太多或太少时，程序就会触发哈希表的扩展或收缩，这两个行为都是通过对字典的哈希表进行 rehash 操作来完成。</p>
<p>​		rehash 操作会重新计算键的哈希值和索引值，然后放到新的哈希表中。</p>
<p>​		为了避免 rehash 期间服务不可用的情况，Redis 采用了渐进式 rehash 的策略，即每次只对原表中的一小部分数据进行迁移，这样在迁移的同时该数据服务仍然可用。</p>
<h5 id="（2）负载因子的计算公式"><a href="#（2）负载因子的计算公式" class="headerlink" title="（2）负载因子的计算公式"></a>（2）负载因子的计算公式</h5><p>​		负载因子 &#x3D; 哈希表已保存节点数量 &#x2F; 哈希表大小，即 ht[0].used &#x2F; ht[0].size</p>
<h5 id="（3）rehash-触发条件"><a href="#（3）rehash-触发条件" class="headerlink" title="（3）rehash 触发条件"></a>（3）rehash 触发条件</h5><p>​		rehash 的触发检测有 2 处，一是依靠 <strong>Redis 定时任务 serverCron</strong> 进行周期检测，二是在执行字典的增删查改操作时检测，其触发条件如下所示。</p>
<ul>
<li>哈希表扩展的触发条件<ul>
<li>服务器目前没有在执行 BGSAVE 命令或者 BGREWRITEAOF 命令，并且哈希表的负载因子大于等于 1</li>
<li>服务器目前正在执行 BGSAVE 命令或者 BGREWRITEAOF 命令，并且哈希表的负载因子大于等于 5</li>
</ul>
</li>
<li>哈希表收缩的触发条件<ul>
<li>负载因子小于 0.1</li>
</ul>
</li>
</ul>
<h5 id="（4）rehash-详细步骤"><a href="#（4）rehash-详细步骤" class="headerlink" title="（4）rehash 详细步骤"></a>（4）rehash 详细步骤</h5><p>​		① 为 ht[1] 分配内存空间，让字典同时持有 ht[0] 和 ht[1] 两个哈希表。扩容时分配的空间为第一个大于或等于 ht[0].used*2 的 2^n，收缩时则为第一个大于或等于 ht[0].used 的 2^n。</p>
<p>​		② 将索引计数器变量 rehashidx 设置为 0 ，表示 rehash 工作开始。</p>
<p>​		③ 在 rehash 进行期间，每次对字典增删查改时，都会顺带将 ht[0] 哈希表索引位置为 rehashidx 上的所有键值对 rehash 到 ht[1] 上面，完成操作后会将 rehashidx 的值加一。</p>
<p>​		④ 当 ht[0] 哈希表上的所有键值对都 rehash 到 ht[1] 上，已经成为一个空表时，将 rehashidx 设置为 -1，表示 rehash 操作已完成。</p>
<h5 id="（5）rehash-期间的操作"><a href="#（5）rehash-期间的操作" class="headerlink" title="（5）rehash 期间的操作"></a>（5）rehash 期间的操作</h5><ul>
<li>查询：先在 ht[0] 表上查询，若查询不到数据则再到 ht[1] 进行查询，最后返回数据</li>
<li>新增：新增的数据会直接添加到 ht[1] 上</li>
<li>删除：ht[0] 和 ht[1] 都需要查询对应的数据然后删除</li>
<li>更新：同删除操作一样</li>
</ul>
<h3 id="四、跳跃表"><a href="#四、跳跃表" class="headerlink" title="四、跳跃表"></a>四、跳跃表</h3><h4 id="1、跳跃表的数据结构与示例"><a href="#1、跳跃表的数据结构与示例" class="headerlink" title="1、跳跃表的数据结构与示例"></a>1、跳跃表的数据结构与示例</h4><p>​		跳跃表（skiplist），简称跳表，它是一种有序数据结构，通过在每个节点维护多个指向其他结点的指针，这些指针形成的链表实际上就是索引，可以实现快速访问结点。</p>
<p>​		跳表的查询时间复杂度平均为 O(logN)，最坏为 O(N)，大部分情况下的查询效率可与平衡树相媲美，并且跳表的实现和原理要更加简单，Redis 作者也是出于结构简单而选择了跳表去实现有序集合键。</p>
<p>​		Redis 内部只在两个地方使用了跳表，一个是作为有序集合键的底层实现之一，另一个则是在集群结点中用作内部数据结构。</p>
<p>​		以下为 Redis 的跳表数据结构定义与示例图。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplist</span> &#123;</span></span><br><span class="line">    structz skiplistNode *header, *tail;<span class="comment">//表头节点和表尾节点</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> length;<span class="comment">//表中节点的数量</span></span><br><span class="line">    <span class="type">int</span> level;<span class="comment">//表中层数最大的节点的层数</span></span><br><span class="line">&#125; zskiplist;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistLevel</span> &#123;</span><span class="comment">//层，新增结点时根据幂次定律随机生成的一个介于1到32之间的值</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">forward</span>;</span><span class="comment">//前进指针</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> span;<span class="comment">//跨度，指两个结点之间的距离</span></span><br><span class="line">    &#125; level[];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">backward</span>;</span><span class="comment">//后退指针</span></span><br><span class="line">    <span class="type">double</span> score;<span class="comment">//分值</span></span><br><span class="line">    robj *obj;<span class="comment">//成员对象</span></span><br><span class="line">&#125; zskiplistNode;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​		</p>
<p><img src="/2020/05/12/redis-d&a-1/image-5.png" alt="image-5"></p>
<div align="center" style="font-size:12px">图1-5 跳表的数据结构示例图</div>

<h4 id="2、跳跃表的增删查"><a href="#2、跳跃表的增删查" class="headerlink" title="2、跳跃表的增删查"></a>2、跳跃表的增删查</h4><p>​		跳表在查询时，会先从最高层索引开始查询，如果查询的值大于当前结点，则跳到下一个节点进行对比，如果查询的值小于下个节点的值，则说明值在两个节点中间，这时程序就会通过后退指针，退回到原先的节点，并且访问原先节点的下一层，这样一层层递进进行判断，如下图中的黄色路线。</p>
<p><img src="/2020/05/12/redis-d&a-1/image-6.jpg" alt="image-6"></p>
<div align="center" style="font-size:12px">图1-6 跳表的查询示例图</div>

<p>​		插入和删除也是同理，在查询到对应的数据位置后进行相应操作，同时还需要维护一下跳表的索引数据。</p>
<p>​		在插入数据时，跳表的索引会动态更新，即通过幂次定律生成一个介于1到32的随机值，这个值代表该节点的最高层数，所有小于或等于该层数的索引，都需要把该新增节点加进去。</p>
<h3 id="五、整数集合"><a href="#五、整数集合" class="headerlink" title="五、整数集合"></a>五、整数集合</h3><h4 id="1、整数集合的数据结构与示例"><a href="#1、整数集合的数据结构与示例" class="headerlink" title="1、整数集合的数据结构与示例"></a>1、整数集合的数据结构与示例</h4><p>​		整数集合（intset），是 Redis 用于保存整数值的集合抽象结构，同时也是集合键的底层实现之一。</p>
<p>​		它用于保存整数值的集合抽象结构，可保存类型为 int16_t、int32_t、int64_t 的整数值，数据按照从小到大进行排序，并且不会出现重复数据。</p>
<p>​		以下为 Redis 的整数集合数据结构定义与示例图，其中 encoding 属性存储着 contents 数组的真正数据类型。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">intset</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> encoding; <span class="comment">//编码方式，有16、32、64三种格式，初始值默认为INTSET_ENC_INT16</span></span><br><span class="line">    <span class="type">uint32_t</span> length;<span class="comment">//集合包含的元素数量</span></span><br><span class="line">    <span class="type">int8_t</span> contents[];<span class="comment">//保存元素的数组，元素类型并不一定是int8_t类型，数组中的元素从小到大排列</span></span><br><span class="line">&#125; intset;</span><br></pre></td></tr></table></figure>

<p>​		<img src="/2020/05/12/redis-d&a-1/image-7.png" alt="image-7"></p>
<div align="center" style="font-size:12px">图1-7 整数集合的数据示例图</div>

<h4 id="2、整数集合的升级和降级"><a href="#2、整数集合的升级和降级" class="headerlink" title="2、整数集合的升级和降级"></a>2、整数集合的升级和降级</h4><h5 id="（1）升级和降级的定义"><a href="#（1）升级和降级的定义" class="headerlink" title="（1）升级和降级的定义"></a>（1）升级和降级的定义</h5><p>​		<strong>升级</strong>：当新元素添加到整数集合，且该新元素的类型比该整数集合现有类型要长的时候，整数集合需要先升级才能容纳下这个新元素，例如某个整数集合的类型是 INSET_ENC_INT32 ，现在有个 int64_t 类型的整数值要添加进去，就会触发整数集合的升级操作。</p>
<p>​		<strong>降级</strong>：出于性能考虑，整数集合并不支持降级操作，所以一旦对数组进行升级，编码就会一直维持着升级后的状态，不会再降回去。</p>
<h5 id="（2）升级的步骤"><a href="#（2）升级的步骤" class="headerlink" title="（2）升级的步骤"></a>（2）升级的步骤</h5><p>​		1）根据新元素的类型，扩展数据集合底层数组的空间大小，并为新元素分配空间</p>
<p>​		2）将底层数组现有的所有元素，数据类型都转换成新类型，并且转换后还要摆放到正确的位置上，以维持底层数组的有序性。注意这里在转换时是 <strong>从后往前</strong> 进行调整的，因为这样才不会造成数据覆盖。</p>
<p>​		3）将新元素添加到底层数组里（由于新元素长度会大于所有现有元素的长度，所以新元素如果是正数则放在最末尾，表示它最大，如果是负数则放在最开头，表示它最小）。</p>
<p><img src="/2020/05/12/redis-d&a-1/image-8.png" alt="image-8"></p>
<div align="center" style="font-size:12px">图1-8 整数集合的升级过程图</div>

<h4 id="3、整数集合升级的好处"><a href="#3、整数集合升级的好处" class="headerlink" title="3、整数集合升级的好处"></a>3、整数集合升级的好处</h4><h5 id="（1）提高灵活性"><a href="#（1）提高灵活性" class="headerlink" title="（1）提高灵活性"></a>（1）提高灵活性</h5><p>​		因为 C 语言是静态类型语言，无法使用同一类型的数组来保存不同类型的数据，例如 int16_t 的数组只能保存 int16_t 的数据，保存不了 int32_t 的数据，会提示类型错误。</p>
<p>​		整数集合可以通过升级的方式，来让集合保存三种不同类型的数据，这样就不用担心出现类型错误的问题。</p>
<h5 id="（2）节约内存"><a href="#（2）节约内存" class="headerlink" title="（2）节约内存"></a>（2）节约内存</h5><p>​		升级的做法，能够让整数集合以尽量小的空间去存储，避免浪费，只有在需要的时候才会对数组进行扩容，升级数据类型。</p>
<h3 id="六、压缩列表"><a href="#六、压缩列表" class="headerlink" title="六、压缩列表"></a>六、压缩列表</h3><h4 id="1、压缩列表的数据结构"><a href="#1、压缩列表的数据结构" class="headerlink" title="1、压缩列表的数据结构"></a>1、压缩列表的数据结构</h4><p>​		压缩列表（ziplist）是列表键和哈希键的底层实现之一，顾名思义，压缩，它是 Redis 为了节约内存而开发出来的 <strong>顺序型数据结构</strong>，由一系列特殊编码的 <strong>连续内存块</strong> 组成，用空间换时间。</p>
<p>​		一个压缩列表可以包含任意多个节点，每个节点可以保存一个字节数组或者一个整数值。</p>
<p>​		下图是压缩列表在内存中的布局（<a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000016901154">图片出处</a>）</p>
<p><img src="/2020/05/12/redis-d&a-1/image-9.png" alt="image-9"></p>
<div align="center" style="font-size:12px">图1-9 压缩列表的内存布局图</div>

<ul>
<li><p>压缩列表的组成（五部分）</p>
<ul>
<li><p><strong>zlbytes</strong>：整个压缩列表占用的内存大小（单位: 字节)，是一个32位无符号整数</p>
</li>
<li><p><strong>zltail</strong>：压缩列表的尾节点距离头节点的偏移量，通过它可直接确定头尾节点的地址</p>
</li>
<li><p><strong>zllen</strong>：压缩列表的节点（entry）个数，仅在该值 <strong>小于</strong> UNIT16_MAX （65535）时有效，当程序查询到该值 <strong>等于</strong> UNIT16_MAX 时就需要遍历整个压缩列表才能得到总节点数</p>
</li>
<li><p><strong>entryX</strong>：存储数据的节点，可以为字节数组或整数</p>
</li>
<li><p><strong>zlend</strong>：特殊值 0xFF （十进制为 255），用于标记压缩列表的末端</p>
</li>
</ul>
</li>
<li><p>压缩列表的节点组成（三部分）</p>
<ul>
<li><p><strong>prevlengh</strong>：记录上个节点的长度，为了方便反向遍历压缩列表，长度为 1 或 5 个字节</p>
<ul>
<li>前 8 位小于 254，表示当前面节点长度小于 254 ，占用内存为 1 个字节</li>
<li>前 8 位等于 254，表示前面节点长度大于或等于 254 ，这时<strong>后 32 位</strong>才是真实的长度，占用内存为 5 个字节。这里不使用 255 而使用 254 作为分界，是因为 255 是 zlend 的值，被用于判断压缩列表的末端</li>
</ul>
</li>
<li><p><strong>encoding</strong>：当前节点的编码规则，用来表示不同长度的字符串或整数，总共可分为 9 类，整数节点 6 类，字符串节点 3 类</p>
<ul>
<li><p>整数节点的 encoding 的长度为8位，其中<strong>高2位</strong>用来区分整数节点和字符串节点（高2位为11时是整数节点，00、01、10则是字符串节点），<strong>低6位</strong>用来区分整数节点的类型，相同 encoding 类型的<strong>整数节点</strong> data 长度是固定的</p>
<p><img src="/2020/05/12/redis-d&a-1/image-10.png" alt="image-10"></p>
<div align="center" style="font-size:12px">图1-10 压缩列表的整数节点类型图</div>
</li>
<li><p>字符串节点的 encoding 有8、16、40位三种长度，相同encoding类型的<strong>字符串节点</strong>，data长度取决于 encoding 后半部分的值。除去开头的 2 位数字，8 位长度剩下的 6 位、16 位长度剩下的 12 位都代表着 data 的实际长度，而 40 位长度则是再去掉 6 位后剩下的 32 位才代表 data 的实际长度，如下图所示。</p>
<p><img src="/2020/05/12/redis-d&a-1/image-11.png" alt="image-11"></p>
<div align="center" style="font-size:12px">图1-11 压缩列表的字符串节点类型图</div></li>
</ul>
</li>
<li><p><strong>data</strong>：用于存储节点真实的数据，可以是数字或字符串，不过比较特殊的是整数 1 ~ 13，因为比较短所以刚好塞在 encoding 里，这时 data 就没存数据，如图 1-10 最下面那条数据所示。</p>
</li>
</ul>
</li>
</ul>
<h4 id="2、连锁更新"><a href="#2、连锁更新" class="headerlink" title="2、连锁更新"></a>2、连锁更新</h4><p>​		由于 prevlengh 字段会记录上一个节点的长度，当上个节点的长度小于 254 时用 1 个字节来保存，大于或等于 254 时则用 5 个字节来保存，所以当压缩列表进行新增或删除数据时，可能会出现一个这样的情况：</p>
<p>​		前一个节点（entry1）的数据长度发生变化，从原先小于 254 变成了大于或等于 254，所以当前节点（entry2）的 prevlengh 就需要更新，从原先 1 个字节变成 5 个字节来存储。</p>
<p>​		由于 prevlengh 是 entryX 里的一个属性，所以如果当前节点（entry2）更新后的长度从原先的小于 254 变成了大于或等于 254，那么下一个节点（entry3）又要进行更新，一直更新到某个节点的 prevlengh 字段不会从 1 个字节变成 5 个字节为止……</p>
<p>​		这种由于单节点的增删而导致的连续多次重新分配内存的操作，被称之为 <strong>连锁更新</strong>。</p>
<p>​		最坏情况会导致压缩列表的所有节点都重新分配内存，而每次分配内存的最坏时间复杂度为 O(n)，所以<strong>连锁更新</strong>的最坏时间复杂度为 O(n^2)。</p>
<p>​		尽管<strong>连锁更新</strong>的时间复杂度很高，但它真正造成性能问题的概率还是比较低的，因为触发条件相对苛刻，需要满足以下2个条件：</p>
<ul>
<li><p>压缩列表中需要有<strong>多个且连续</strong>的、长度为 <strong>250 ~ 253</strong> 的节点</p>
</li>
<li><p>这种连续节点的<strong>数量要多</strong>，如果个数不多，那么并不会对性能造成多大影响</p>
<p>基于上述情况，压缩列表的平均时间复杂度仅为 O(n)，不用太担心连锁更新的性能问题</p>
</li>
</ul>

    </div>

    
    
    

    <footer class="post-footer">
          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>量子猫
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="https://mercuriussss.github.io/2020/05/12/redis-d&a-1/" title="一、Redis底层数据结构">https://mercuriussss.github.io/2020/05/12/redis-d&a-1/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/tags/Redis/" rel="tag"># Redis</a>
              <a href="/tags/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/" rel="tag"># Redis设计与实现</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2020/03/20/java-collection-1/" rel="prev" title="为何 Hashtable、ConcurrentHashMap 不允许键或值为空，而 HashMap 允许">
                  <i class="fa fa-chevron-left"></i> 为何 Hashtable、ConcurrentHashMap 不允许键或值为空，而 HashMap 允许
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2023/03/15/redis-d&a-2/" rel="next" title="二、Redis底层通用对象">
                  二、Redis底层通用对象 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">量子猫</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">59k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">2:27</span>
  </span>
</div>
<div class="busuanzi-count">
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>





  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>





</body>
</html>
