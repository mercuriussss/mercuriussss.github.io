<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>二、Redis底层通用对象</title>
      <link href="/2023/03/15/redis-d&amp;a-2/"/>
      <url>/2023/03/15/redis-d&amp;a-2/</url>
      
        <content type="html"><![CDATA[<h3 id="1、对象的类型与编码"><a href="#1、对象的类型与编码" class="headerlink" title="1、对象的类型与编码"></a>1、对象的类型与编码</h3><p>​Redis 使用对象来表示数据库中的键和值，即使用 Redis 创建一个键值对时，至少会创建两个对象，键和值会用不同的对象进行存储。</p><p>​Redis 中的每个对象都由 reidsObject 结构表示，占用空间为 (4 + 4 + 64 + 24 +32)&#x2F;8 &#x3D; 16 字节</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> type:<span class="number">4</span>;<span class="comment">//类型，占4bits，包含RESDIS_STRING、REDIS_LIST、REDIS_HASH、REDIS_SET、REDIS_ZSET</span></span><br><span class="line">    <span class="type">unsigned</span> encoding:<span class="number">4</span>;<span class="comment">//编码，占4bits</span></span><br><span class="line">    <span class="type">void</span> *ptr;<span class="comment">//占64bits，指向底层实现数据结构的指针</span></span><br><span class="line">    <span class="type">unsigned</span> lru:REDIS_LRU_BITS; <span class="comment">// 占24bits，lru记录此对象最后一次访问的时间</span></span><br><span class="line">    <span class="type">int</span> refcount; <span class="comment">// 占32bits，当前表示有多少个对象在引用它，为0时可以释放，类似JVM垃圾回收</span></span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure><h3 id="2、各个对象的底层编码"><a href="#2、各个对象的底层编码" class="headerlink" title="2、各个对象的底层编码"></a>2、各个对象的底层编码</h3><h4 id="（1）字符串"><a href="#（1）字符串" class="headerlink" title="（1）字符串"></a>（1）字符串</h4><p>​当字符串保存的是正数、且数值在long类型范围内时，使用 int 编码。</p><p>​当字符串保存的是字符串，且字符串长度小于或等于 32 字节时使用 embstr 编码，大于 32 字节则使用 raw 编码。</p><p>​int 和 embstr 编码的字符串，在条件满足的情况下会被转换为 raw 编码的字符串对象。</p><p>​对于 int 编码，如果向对象执行一些命令，导致其保存的不再是整数值，那么该字符串编码会转为 raw 。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">redis＞ SET number <span class="number">10086</span></span><br><span class="line">OK</span><br><span class="line">redis＞ OBJECT ENCODING number</span><br><span class="line"><span class="string">&quot;int&quot;</span></span><br><span class="line">redis＞ APPEND number <span class="string">&quot; is a good number!&quot;</span></span><br><span class="line">(integer) <span class="number">23</span></span><br><span class="line">redis＞ GET number</span><br><span class="line"><span class="string">&quot;10086 is a good number!&quot;</span></span><br><span class="line">redis＞ OBJECT ENCODING number</span><br><span class="line"><span class="string">&quot;raw&quot;</span></span><br></pre></td></tr></table></figure><p>​对于 embstr 编码，Redis 实际上没有为其编写修改程序，该编码类型的对象只能是只读。当程序对 embstr 编码的字符串进行修改时，程序会先将编码从 embstr 改成 raw，再去执行修改命令，并且修改后的编码类型还是 raw。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">redis＞ SET msg <span class="string">&quot;hello world&quot;</span></span><br><span class="line">OK</span><br><span class="line">redis＞ OBJECT ENCODING msg</span><br><span class="line"><span class="string">&quot;embstr&quot;</span></span><br><span class="line">redis＞ APPEND msg <span class="string">&quot; again!&quot;</span></span><br><span class="line">(integer) <span class="number">18</span></span><br><span class="line">redis＞ OBJECT ENCODING msg</span><br><span class="line"><span class="string">&quot;raw&quot;</span></span><br></pre></td></tr></table></figure><h4 id="（2）列表"><a href="#（2）列表" class="headerlink" title="（2）列表"></a>（2）列表</h4><p>​当列表总元素数量小于512，且每个元素的长度都小于64字节时，列表使用 ziplist 作为编码，否则使用 linkedlist 作为编码。</p><p>​Redis 在 <strong>3.2</strong> 版本后，废弃了上面的规则，对于列表只使用 <strong>quicklist</strong> 这种编码进行存储。</p><p>​quicklist 的数据结构是结合了 ziplist 和 linkedlist 实现的，同时具有 linkedlist 按段切分、双指针以及 ziplist 压缩存储数据的特性</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklist</span> &#123;</span></span><br><span class="line">    quicklistNode *head;</span><br><span class="line">    quicklistNode *tail;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> count; <span class="comment">// 所有压缩列表中元素的总数量</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> len; <span class="comment">// 快速列表的节点总数量</span></span><br><span class="line">    <span class="type">int</span> fill : <span class="number">16</span>; <span class="comment">// 压缩列表的最大大小,如果节点超出该数值就会新建一个压缩列表</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> compress : <span class="number">16</span>; <span class="comment">// 节点压缩深度，0表示不压缩</span></span><br><span class="line">&#125; quicklist;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklistNode</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">quicklistNode</span> *<span class="title">prev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">quicklistNode</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *zl;<span class="comment">// 指向压缩列表的指针,如果当前节点数据被压缩，就会指向 quicklistLZF</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> sz;  <span class="comment">// 压缩列表的所占字节总数</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> count : <span class="number">16</span>;  <span class="comment">// 压缩列表中的元素数量</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> encoding : <span class="number">2</span>;   <span class="comment">// 该节点当前使用的编码，1表示原生，2表示LZF，后者表示被压缩过</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> container : <span class="number">2</span>;  <span class="comment">// 标记quicklistNode节点是否采用ziplist结构保存数据，2表示压缩了，1表示没压缩</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> recompress : <span class="number">1</span>; <span class="comment">// 标记quicklist节点的ziplist之前是否被解压缩</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> attempted_compress : <span class="number">1</span>; <span class="comment">/* node can&#x27;t compress; too small */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> extra : <span class="number">10</span>; <span class="comment">/* more bits to steal for future usage */</span></span><br><span class="line">&#125; quicklistNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklistLZF</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> sz; <span class="comment">// 被LZF算法压缩后的ziplist大小</span></span><br><span class="line">    <span class="type">char</span> compressed[]; <span class="comment">// 被压缩后的ziplist柔性数组</span></span><br><span class="line">&#125; quicklistLZF;</span><br></pre></td></tr></table></figure><p><img src="/2023/03/15/redis-d&a-2/image-1.png" alt="image-1"></p><div align="center" style="font-size:12px">图1 quicklist数据结构示例图</div><h4 id="（3）哈希"><a href="#（3）哈希" class="headerlink" title="（3）哈希"></a>（3）哈希</h4><p>​哈希对象的编码可以为 ziplist 或 hashtable。</p><p>​底层为 ziplist 编码，需满足 2 个条件：对象保存的所有键值对的键和值大小都小于 64 字节，对象保存的键值对数量小于 512。（注：这两个上限值都可以通过配置文件进行调整）</p><p>​不满足 ziplist 条件的就使用 hashtable 编码。</p><h4 id="（4）集合"><a href="#（4）集合" class="headerlink" title="（4）集合"></a>（4）集合</h4><p>​集合对象的编码可以为 intset 或 hashtable。</p><p>​底层为 intset 编码，需满足 2 个条件：对象保存的所有元素都是整数，对象保存的总元素数量小于 512。（注：该上限值可以通过配置文件进行调整）</p><p>​不满足 intset 条件的就使用 hashtable 编码。</p><h4 id="（5）有序集合"><a href="#（5）有序集合" class="headerlink" title="（5）有序集合"></a>（5）有序集合</h4><p>​有序对象的编码可以为 ziplist 或 skiplist。</p><p>​底层为 ziplist 编码，需满足 2 个条件：对象保存的所有元素成员大小都小于 64 字节，对象保存的总元素数量小于 128。（注：这两个上限值都可以通过配置文件进行调整）</p><p>​不满足 ziplist 条件的就使用 skiplist 编码。</p><h4 id="（6）汇总图"><a href="#（6）汇总图" class="headerlink" title="（6）汇总图"></a>（6）汇总图</h4><p><img src="/2023/03/15/redis-d&a-2/image-111.png" alt="image-1"></p><div align="center" style="font-size:12px">图1 SDS数据结构示例图</div><h3 id="3、类型检查和命令多态"><a href="#3、类型检查和命令多态" class="headerlink" title="3、类型检查和命令多态"></a>3、类型检查和命令多态</h3><p>​Redis 中用于操作键的命令有 2 种。</p><p>​第一种是通用的、可以对所有键进行操作的命令，例如 DEL 命令、EXPIRE 命令、TYPE 命令等，它是通过读取 redisObject 结构中的   type 属性来实现的。</p><p>​第二种是特定的命令，例如使用 HSET、HDEL 操作哈希键，使用 SADD、SPOP 操作集合键等，如果这些特定命令操作了非特定类型的数据，则会返回类型错误。</p><p>​<strong>类型检查</strong>：特定类型的命令只会执行对应类型的数据，否则就会返回类型错误</p><p>​<strong>命令多态</strong>：除了会根据 redisObject 中的 type 属性来判断对象类型是否能执行指定命令，还会根据值对象的编码方式选择正确的命令代码来执行，例如 LLEN 命令的底层可能 ziplist 编码或 linkedlist 编码，二者获取长度的方法不一样</p><h3 id="4、内存回收"><a href="#4、内存回收" class="headerlink" title="4、内存回收"></a>4、内存回收</h3><p>​C 语言并不具备自动回收内存功能，所以 Redis 自己构建了一个由引用计数技术实现的内存回收机制。</p><p>​redisObject 对象中有一个 refcount 属性，它的初始化值是 1，并且每被一个新程序使用时就会加一，若程序不再使用则计数值对应扣减一，当它为 0 的时候，所占用的内存就会被释放掉。</p><h3 id="5、对象共享"><a href="#5、对象共享" class="headerlink" title="5、对象共享"></a>5、对象共享</h3><p>​redisObject 对象中的 <strong>refcount</strong> 属性，除了实现垃圾回收外，还带有对象共享的作用。</p><p>​为了节约内存，redis 会在初始化服务器时，创建一万个字符串对象，其中包含了 0 到 9999 的所有整数值，当服务器需要用到这些字符串对象时就会直接使用，而不是去新创建对象。</p><p>​同时出于性能考虑，这里的共享对象只包含一万个整数值，并没有字符串，因为如果是共享字符串对象，那么每次都需要去检查键和值对象是否相同的时间复杂度就会变高。</p><p>​对比保存整数值的字符串对象，时间复杂度是 O(1)；</p><p>​对比保存字符串值的字符串对象，时间复杂度是 O(N);</p><p>​对比保存多个值的对象，例如列表对象或哈希对象，时间复杂度是 O(N^2)。</p><h3 id="6、对象的空转时长"><a href="#6、对象的空转时长" class="headerlink" title="6、对象的空转时长"></a>6、对象的空转时长</h3><p>​redisObject 对象中的 <strong>lru</strong> 属性，会记录对象最后一次被访问的时间</p><hr><p>ref:</p><p>《Redis设计与实现》第三版</p><p>Redis｜快速表、压缩表和双向链表：<a href="https://blog.csdn.net/MarkusZhang/article/details/109000894">https://blog.csdn.net/MarkusZhang/article/details/109000894</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> Redis设计与实现 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一、Redis底层数据结构</title>
      <link href="/2020/05/12/redis-d&amp;a-1/"/>
      <url>/2020/05/12/redis-d&amp;a-1/</url>
      
        <content type="html"><![CDATA[<h3 id="一、简单动态字符串"><a href="#一、简单动态字符串" class="headerlink" title="一、简单动态字符串"></a>一、简单动态字符串</h3><h4 id="1、SDS的数据结构与示例"><a href="#1、SDS的数据结构与示例" class="headerlink" title="1、SDS的数据结构与示例"></a>1、SDS的数据结构与示例</h4><p>​Redis 是用 C 语言开发的一个高性能缓存框架，支持五种基本的数据结构，这些数据结构的底层也是由 C 语言实现的。</p><p>​大多数情况下，Redis 用于存储字符串的结构为简单动态字符串（Simple Dynamic String），简称 SDS，其底层实现如下所示。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> len;     <span class="comment">//记录buf数组已使用字节数量，即字符串长度</span></span><br><span class="line">    <span class="type">int</span> <span class="built_in">free</span>;    <span class="comment">//记录buf数组未使用字节数量，即剩余空间</span></span><br><span class="line">    <span class="type">char</span> buf[];  <span class="comment">//字节数组，用于保存字符串</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/05/12/redis-d&a-1/image-20210401100415782.png" alt="image-20210401100415782"></p><div align="center" style="font-size:12px">图1-1 SDS数据结构示例图</div><h4 id="2、SDS跟C字符串的区别（优势）"><a href="#2、SDS跟C字符串的区别（优势）" class="headerlink" title="2、SDS跟C字符串的区别（优势）"></a>2、SDS跟C字符串的区别（优势）</h4><h5 id="（1）常数复杂度获取字符串长度"><a href="#（1）常数复杂度获取字符串长度" class="headerlink" title="（1）常数复杂度获取字符串长度"></a>（1）常数复杂度获取字符串长度</h5><p>​C字符串获取长度时，需要遍历整个字符串，其时间复杂度为O(N)</p><p>​SDS则本身len属性记录了长度，获取长度的时间复杂度仅为O(1)</p><h5 id="（2）杜绝缓存区溢出"><a href="#（2）杜绝缓存区溢出" class="headerlink" title="（2）杜绝缓存区溢出"></a>（2）杜绝缓存区溢出</h5><p>​C字符串如果在追加字符前未给该字符串分配足够多的内存空间，那么该字符串的数据可能会溢出、污染到相邻空间的内存数据。</p><table><thead><tr><th align="center">str 1</th><th align="center">str 2</th></tr></thead><tbody><tr><td align="center">Redis</td><td align="center">MongoDB</td></tr></tbody></table><table><thead><tr><th align="center">str 1</th><th align="center">str 2</th></tr></thead><tbody><tr><td align="center">Redis</td><td align="center">Cluster</td></tr></tbody></table><p>​例如 str1 和 str2 在内存中是紧挨着的，然后 str1 使用 strcat 方法追加内容”Cluster”，那么 str1 的数据将溢出到 str2 的内存空间里，在 str2 不知情的情况下将”MongoDB”修改成了”Cluster”，这是 <strong>C 语言的缓冲区溢出问题，即 API 的调用是不安全的</strong>。</p><p>​SDS 则没有该问题的存在，在对字符串进行拼接操作时，它会先检查字符串的长度是否足够，即 free 的空间是否足够，若不足则会先扩展空间再进行拼接操作</p><h5 id="（3）减少修改字符串时的内存重分配次数"><a href="#（3）减少修改字符串时的内存重分配次数" class="headerlink" title="（3）减少修改字符串时的内存重分配次数"></a>（3）减少修改字符串时的内存重分配次数</h5><p>​C 字符串在进行<strong>增长字符串</strong>操作时，若没在操作前通过内存重分配来<strong>扩展空间</strong>，那就有可能产生<strong>缓冲区溢出</strong>的问题。</p><p>​C 字符串在进行<strong>缩短字符串</strong>操作时，若没在操作前通过内存重分配来<strong>释放空间</strong>，那就有可能产生<strong>内存泄漏</strong>的问题。</p><p>​Redis 当然不可能每次操作都进行内存重分配，那样会相当影响性能，于是 SDS 使用空间预分配和惰性空间释放两种策略来进行优化。</p><ul><li><p>内存预分配</p><ul><li><p>当 SDS 修改后的长度（即 len 属性值）小于 1M 时，程序除了为其分配修改后的长度的内存空间，还会为其分配同等长度的未使用空间。</p><p>例如，若 SDS 的 len 修改后变成 13 字节，那么程序会为其分配 13 字节的未使用空间，最终 buf 数组的长度为 13 + 13 + 1 &#x3D; 27 字节</p></li><li><p>当 SDS 修改后的长度（即 len 属性值）大于 1M 时，程序除了分配应有的空间外，还会为其分配 1M 的未使用空间。</p><p>例如，若 SDS 的 len 修改后变成 30M，那么程序会分配 1M 的未使用空间，最终 buf 数组的长度为 30M + 1M + 1 byte</p></li></ul></li><li><p>惰性空间释放</p><p>定义：当 SDS 的 API 需要缩短字符串时，程序不会立即用内存重分配去回收空间，而是用 free 属性将这部分长度记录起来，等待再次使用。</p><p>优点：这样做能避免缩短字符串带来的内存重分配操作，并为之后可能有的增长操作提供优化。</p><p>​同时，SDS 也提供了相应的 API 可以在有需要时释放 SDS 的未使用空间，所以不必担心惰性空间策略的内存浪费问题。</p></li></ul><h5 id="（4）二进制安全"><a href="#（4）二进制安全" class="headerlink" title="（4）二进制安全"></a>（4）二进制安全</h5><ul><li><p>C 字符串中的字符必须符合某种编码（例如 ASCII ），并且除末尾外中间不能包含空字符，C 字符串只能用来保存文本数据。</p></li><li><p>Redis 的 SDS 不仅可以保存文本数据，还可以保存任意格式的二进制数据，例如图片、音频、视频、压缩文件等</p><p>Redis 的 SDS API 采用了二进制的处理方式将数据保存到 buf 数组中，buf 数组保存的不是字符，而是一系列二进制数据，因此它也被称作<strong>字节数组</strong>。</p></li></ul><h4 id="3、SDS兼容部分C字符串函数"><a href="#3、SDS兼容部分C字符串函数" class="headerlink" title="3、SDS兼容部分C字符串函数"></a>3、SDS兼容部分C字符串函数</h4><p>​虽然 SDS 的 API 都是二进制安全的，但它们同样遵循着 C 字符串以空字符结尾的惯例，这是为了让 SDS 可以重用一部分 &lt;string.h&gt; 函数，避免重复造轮子。</p><h3 id="二、链表"><a href="#二、链表" class="headerlink" title="二、链表"></a>二、链表</h3><h4 id="1、链表的数据结构与示例"><a href="#1、链表的数据结构与示例" class="headerlink" title="1、链表的数据结构与示例"></a>1、链表的数据结构与示例</h4><p>​链表在 Redis 中的应用相当广泛，例如列表键的底层实现之一就是链表，并且<strong>发布与订阅、慢查询、监视器</strong>等功能也用到了列表。</p><p>​以下为 Redis 的链表数据结构定义。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span> &#123;</span></span><br><span class="line">    listNode * head; <span class="comment">// 表头节点</span></span><br><span class="line">    listNode * tail; <span class="comment">// 表尾节点</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> len; <span class="comment">// 链表所包含的节点数量</span></span><br><span class="line">    <span class="type">void</span> *(*dup)(<span class="type">void</span> *ptr); <span class="comment">// 节点值复制函数</span></span><br><span class="line">    <span class="type">void</span> (*<span class="built_in">free</span>)(<span class="type">void</span> *ptr); <span class="comment">// 节点值释放函数</span></span><br><span class="line">    <span class="type">int</span> (*match)(<span class="type">void</span> *ptr,<span class="type">void</span> *key); <span class="comment">// 节点值对比函数</span></span><br><span class="line">&#125; <span class="built_in">list</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> * <span class="title">prev</span>;</span> <span class="comment">// 前置节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> * <span class="title">next</span>;</span> <span class="comment">// 后置节点</span></span><br><span class="line">    <span class="type">void</span> * value; <span class="comment">//节点的值</span></span><br><span class="line">&#125;listNode;</span><br></pre></td></tr></table></figure><p>​下图为一个 list 结构和三个 listNode 结构所组成的链表</p><p><img src="/2020/05/12/redis-d&a-1/image-2.png" alt="image-2"></p><div align="center" style="font-size:12px">图1-2 链表数据结构示例图</div><h4 id="2、链表的特性"><a href="#2、链表的特性" class="headerlink" title="2、链表的特性"></a>2、链表的特性</h4><ul><li>双端：链表结点带有 prev 和 next 指针</li><li>无环：头结点的 prev 和尾结点的 next ，两个指针都指向 NULL</li><li>带头尾指针： list 结构中含有头尾指针，可直接获取</li><li>带链表长度计数器： list 结构中含有 len 属性，保存着整个链表的数量</li><li>多态：表节点使用void*指针来保存节点值，并且可以通过list结构的dup、free、match三个属性为节点值设置类型特定函数，所以链表可以用于保存各种不同类型的值</li></ul><h3 id="三、字典"><a href="#三、字典" class="headerlink" title="三、字典"></a>三、字典</h3><h4 id="1、字典的数据结构与示例"><a href="#1、字典的数据结构与示例" class="headerlink" title="1、字典的数据结构与示例"></a>1、字典的数据结构与示例</h4><p>​字典（dict），又称为符号表、关联数组或映射，底层实现为哈希表，是一种用于保存键值对的抽象数据结构。</p><p>​Redis 的数据库使用了字典作为底层实现，对数据库的增删查改操作都是构建在对字典的操作之上，同时字典也是哈希键的底层实现之一。</p><p>​以下为 Redis 的字典数据结构定义，其中 type 和 privdata 属性是针对不同类型的键值对，为创建多态字典而设置的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字典</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></span><br><span class="line">    dictType *type;<span class="comment">//类型特定函数</span></span><br><span class="line">    <span class="type">void</span> *privdata;<span class="comment">//私有数据</span></span><br><span class="line">    dictht ht[<span class="number">2</span>];<span class="comment">//哈希表</span></span><br><span class="line">    <span class="type">int</span> rehashidx; <span class="comment">// rehash索引，当rehash不在进行时，值为-1</span></span><br><span class="line">&#125; dict;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型特定函数</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictType</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="title function_">int</span> <span class="params">(*hashFunction)</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *key)</span>;<span class="comment">//计算哈希值的函数</span></span><br><span class="line">    <span class="type">void</span> *(*keyDup)(<span class="type">void</span> *privdata, <span class="type">const</span> <span class="type">void</span> *key);<span class="comment">//复制键的函数</span></span><br><span class="line">    <span class="type">void</span> *(*valDup)(<span class="type">void</span> *privdata, <span class="type">const</span> <span class="type">void</span> *obj);<span class="comment">//复制值的函数</span></span><br><span class="line">    <span class="type">int</span> (*keyCompare)(<span class="type">void</span> *privdata, <span class="type">const</span> <span class="type">void</span> *key1, <span class="type">const</span> <span class="type">void</span> *key2);<span class="comment">//对比键的函数</span></span><br><span class="line">    <span class="type">void</span> (*keyDestructor)(<span class="type">void</span> *privdata, <span class="type">void</span> *key);<span class="comment">//销毁键的函数</span></span><br><span class="line">    <span class="type">void</span> (*valDestructor)(<span class="type">void</span> *privdata, <span class="type">void</span> *obj);<span class="comment">//销毁值的函数</span></span><br><span class="line">&#125; dictType;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 哈希表</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span> &#123;</span></span><br><span class="line">    dictEntry **table;&#123;<span class="comment">//哈希表数组</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> size;<span class="comment">//哈希表大小</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> sizemask;<span class="comment">//哈希表大小掩码，用于计算索引值，总是等于size-1</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> used;<span class="comment">//该哈希表已有节点的数量</span></span><br><span class="line">&#125; dictht;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 哈希表节点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span></span><br><span class="line">    <span class="type">void</span> *key;<span class="comment">//键</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span>&#123;</span> <span class="comment">//值</span></span><br><span class="line">        <span class="type">void</span> *val;</span><br><span class="line">        uint64_tu64;</span><br><span class="line">        int64_ts64;</span><br><span class="line">    &#125; v;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span><span class="comment">//指向下个哈希表节点，形成链表</span></span><br><span class="line">&#125; dictEntry;</span><br></pre></td></tr></table></figure><p>​下图为一个普通状态下（没有进行rehash）的字典。</p><p>​<img src="/2020/05/12/redis-d&a-1/image-3.png" alt="image-3"></p><div align="center" style="font-size:12px">图1-3 字典数据结构示例图</div><h4 id="2、哈希算法与键冲突"><a href="#2、哈希算法与键冲突" class="headerlink" title="2、哈希算法与键冲突"></a>2、哈希算法与键冲突</h4><p>​当 Redis 要将一个新的键值对添加到字典中时，程序要先根据key计算出哈希值和索引值，目前 Redis 用于计算哈希值的算法为 <strong>MurmurHash2 一致性哈希算法</strong>，其优点是计算速度快、随机分布性良好，而 MurmurHash 算法最新版本为 MurmurHash3 。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#使用字典设置的哈希函数，计算键key的哈希值 </span><br><span class="line">hash = dict-＞type-＞hashFunction(key); </span><br><span class="line"></span><br><span class="line">#使用哈希表的sizemask属性和哈希值，计算出索引值 </span><br><span class="line">#根据情况不同，ht[x]可以是ht[<span class="number">0</span>]或者ht[<span class="number">1</span>] </span><br><span class="line">index = hash &amp; dict-＞ht[x].sizemask;</span><br></pre></td></tr></table></figure><p>​在计算完哈希值和索引值后，程序会将节点放到对应的索引位置上，如果遇到键冲突则使用链地址法来解决，并且从速度考虑，每次添加新节点都会添加到表头的位置，即头插法。</p><p>​如下图所示，新增的键值对k2会添加到k1前面。</p><p><img src="/2020/05/12/redis-d&a-1/image-4.png" alt="image-4"></p><div align="center" style="font-size:12px">图1-4 链地址法解决键冲突</div><h4 id="3、渐进式rehash"><a href="#3、渐进式rehash" class="headerlink" title="3、渐进式rehash"></a>3、渐进式rehash</h4><h5 id="（1）rehash-定义"><a href="#（1）rehash-定义" class="headerlink" title="（1）rehash 定义"></a>（1）rehash 定义</h5><p>​为了让哈希表的负载因子维持在一个合理的范围内，当哈希表保存的键值对数量太多或太少时，程序就会触发哈希表的扩展或收缩，这两个行为都是通过对字典的哈希表进行 rehash 操作来完成。</p><p>​rehash 操作会重新计算键的哈希值和索引值，然后放到新的哈希表中。</p><p>​为了避免 rehash 期间服务不可用的情况，Redis 采用了渐进式 rehash 的策略，即每次只对原表中的一小部分数据进行迁移，这样在迁移的同时该数据服务仍然可用。</p><h5 id="（2）负载因子的计算公式"><a href="#（2）负载因子的计算公式" class="headerlink" title="（2）负载因子的计算公式"></a>（2）负载因子的计算公式</h5><p>​负载因子 &#x3D; 哈希表已保存节点数量 &#x2F; 哈希表大小，即 ht[0].used &#x2F; ht[0].size</p><h5 id="（3）rehash-触发条件"><a href="#（3）rehash-触发条件" class="headerlink" title="（3）rehash 触发条件"></a>（3）rehash 触发条件</h5><p>​rehash 的触发检测有 2 处，一是依靠 <strong>Redis 定时任务 serverCron</strong> 进行周期检测，二是在执行字典的增删查改操作时检测，其触发条件如下所示。</p><ul><li>哈希表扩展的触发条件<ul><li>服务器目前没有在执行 BGSAVE 命令或者 BGREWRITEAOF 命令，并且哈希表的负载因子大于等于 1</li><li>服务器目前正在执行 BGSAVE 命令或者 BGREWRITEAOF 命令，并且哈希表的负载因子大于等于 5</li></ul></li><li>哈希表收缩的触发条件<ul><li>负载因子小于 0.1</li></ul></li></ul><h5 id="（4）rehash-详细步骤"><a href="#（4）rehash-详细步骤" class="headerlink" title="（4）rehash 详细步骤"></a>（4）rehash 详细步骤</h5><p>​① 为 ht[1] 分配内存空间，让字典同时持有 ht[0] 和 ht[1] 两个哈希表。扩容时分配的空间为第一个大于或等于 ht[0].used*2 的 2^n，收缩时则为第一个大于或等于 ht[0].used 的 2^n。</p><p>​② 将索引计数器变量 rehashidx 设置为 0 ，表示 rehash 工作开始。</p><p>​③ 在 rehash 进行期间，每次对字典增删查改时，都会顺带将 ht[0] 哈希表索引位置为 rehashidx 上的所有键值对 rehash 到 ht[1] 上面，完成操作后会将 rehashidx 的值加一。</p><p>​④ 当 ht[0] 哈希表上的所有键值对都 rehash 到 ht[1] 上，已经成为一个空表时，将 rehashidx 设置为 -1，表示 rehash 操作已完成。</p><h5 id="（5）rehash-期间的操作"><a href="#（5）rehash-期间的操作" class="headerlink" title="（5）rehash 期间的操作"></a>（5）rehash 期间的操作</h5><ul><li>查询：先在 ht[0] 表上查询，若查询不到数据则再到 ht[1] 进行查询，最后返回数据</li><li>新增：新增的数据会直接添加到 ht[1] 上</li><li>删除：ht[0] 和 ht[1] 都需要查询对应的数据然后删除</li><li>更新：同删除操作一样</li></ul><h3 id="四、跳跃表"><a href="#四、跳跃表" class="headerlink" title="四、跳跃表"></a>四、跳跃表</h3><h4 id="1、跳跃表的数据结构与示例"><a href="#1、跳跃表的数据结构与示例" class="headerlink" title="1、跳跃表的数据结构与示例"></a>1、跳跃表的数据结构与示例</h4><p>​跳跃表（skiplist），简称跳表，它是一种有序数据结构，通过在每个节点维护多个指向其他结点的指针，这些指针形成的链表实际上就是索引，可以实现快速访问结点。</p><p>​跳表的查询时间复杂度平均为 O(logN)，最坏为 O(N)，大部分情况下的查询效率可与平衡树相媲美，并且跳表的实现和原理要更加简单，Redis 作者也是出于结构简单而选择了跳表去实现有序集合键。</p><p>​Redis 内部只在两个地方使用了跳表，一个是作为有序集合键的底层实现之一，另一个则是在集群结点中用作内部数据结构。</p><p>​以下为 Redis 的跳表数据结构定义与示例图。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplist</span> &#123;</span></span><br><span class="line">    structz skiplistNode *header, *tail;<span class="comment">//表头节点和表尾节点</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> length;<span class="comment">//表中节点的数量</span></span><br><span class="line">    <span class="type">int</span> level;<span class="comment">//表中层数最大的节点的层数</span></span><br><span class="line">&#125; zskiplist;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistLevel</span> &#123;</span><span class="comment">//层，新增结点时根据幂次定律随机生成的一个介于1到32之间的值</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">forward</span>;</span><span class="comment">//前进指针</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> span;<span class="comment">//跨度，指两个结点之间的距离</span></span><br><span class="line">    &#125; level[];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">backward</span>;</span><span class="comment">//后退指针</span></span><br><span class="line">    <span class="type">double</span> score;<span class="comment">//分值</span></span><br><span class="line">    robj *obj;<span class="comment">//成员对象</span></span><br><span class="line">&#125; zskiplistNode;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​</p><p><img src="/2020/05/12/redis-d&a-1/image-5.png" alt="image-5"></p><div align="center" style="font-size:12px">图1-5 跳表的数据结构示例图</div><h4 id="2、跳跃表的增删查"><a href="#2、跳跃表的增删查" class="headerlink" title="2、跳跃表的增删查"></a>2、跳跃表的增删查</h4><p>​跳表在查询时，会先从最高层索引开始查询，如果查询的值大于当前结点，则跳到下一个节点进行对比，如果查询的值小于下个节点的值，则说明值在两个节点中间，这时程序就会通过后退指针，退回到原先的节点，并且访问原先节点的下一层，这样一层层递进进行判断，如下图中的黄色路线。</p><p><img src="/2020/05/12/redis-d&a-1/image-6.jpg" alt="image-6"></p><div align="center" style="font-size:12px">图1-6 跳表的查询示例图</div><p>​插入和删除也是同理，在查询到对应的数据位置后进行相应操作，同时还需要维护一下跳表的索引数据。</p><p>​在插入数据时，跳表的索引会动态更新，即通过幂次定律生成一个介于1到32的随机值，这个值代表该节点的最高层数，所有小于或等于该层数的索引，都需要把该新增节点加进去。</p><h3 id="五、整数集合"><a href="#五、整数集合" class="headerlink" title="五、整数集合"></a>五、整数集合</h3><h4 id="1、整数集合的数据结构与示例"><a href="#1、整数集合的数据结构与示例" class="headerlink" title="1、整数集合的数据结构与示例"></a>1、整数集合的数据结构与示例</h4><p>​整数集合（intset），是 Redis 用于保存整数值的集合抽象结构，同时也是集合键的底层实现之一。</p><p>​它用于保存整数值的集合抽象结构，可保存类型为 int16_t、int32_t、int64_t 的整数值，数据按照从小到大进行排序，并且不会出现重复数据。</p><p>​以下为 Redis 的整数集合数据结构定义与示例图，其中 encoding 属性存储着 contents 数组的真正数据类型。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">intset</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> encoding; <span class="comment">//编码方式，有16、32、64三种格式，初始值默认为INTSET_ENC_INT16</span></span><br><span class="line">    <span class="type">uint32_t</span> length;<span class="comment">//集合包含的元素数量</span></span><br><span class="line">    <span class="type">int8_t</span> contents[];<span class="comment">//保存元素的数组，元素类型并不一定是int8_t类型，数组中的元素从小到大排列</span></span><br><span class="line">&#125; intset;</span><br></pre></td></tr></table></figure><p>​<img src="/2020/05/12/redis-d&a-1/image-7.png" alt="image-7"></p><div align="center" style="font-size:12px">图1-7 整数集合的数据示例图</div><h4 id="2、整数集合的升级和降级"><a href="#2、整数集合的升级和降级" class="headerlink" title="2、整数集合的升级和降级"></a>2、整数集合的升级和降级</h4><h5 id="（1）升级和降级的定义"><a href="#（1）升级和降级的定义" class="headerlink" title="（1）升级和降级的定义"></a>（1）升级和降级的定义</h5><p>​<strong>升级</strong>：当新元素添加到整数集合，且该新元素的类型比该整数集合现有类型要长的时候，整数集合需要先升级才能容纳下这个新元素，例如某个整数集合的类型是 INSET_ENC_INT32 ，现在有个 int64_t 类型的整数值要添加进去，就会触发整数集合的升级操作。</p><p>​<strong>降级</strong>：出于性能考虑，整数集合并不支持降级操作，所以一旦对数组进行升级，编码就会一直维持着升级后的状态，不会再降回去。</p><h5 id="（2）升级的步骤"><a href="#（2）升级的步骤" class="headerlink" title="（2）升级的步骤"></a>（2）升级的步骤</h5><p>​1）根据新元素的类型，扩展数据集合底层数组的空间大小，并为新元素分配空间</p><p>​2）将底层数组现有的所有元素，数据类型都转换成新类型，并且转换后还要摆放到正确的位置上，以维持底层数组的有序性。注意这里在转换时是 <strong>从后往前</strong> 进行调整的，因为这样才不会造成数据覆盖。</p><p>​3）将新元素添加到底层数组里（由于新元素长度会大于所有现有元素的长度，所以新元素如果是正数则放在最末尾，表示它最大，如果是负数则放在最开头，表示它最小）。</p><p><img src="/2020/05/12/redis-d&a-1/image-8.png" alt="image-8"></p><div align="center" style="font-size:12px">图1-8 整数集合的升级过程图</div><h4 id="3、整数集合升级的好处"><a href="#3、整数集合升级的好处" class="headerlink" title="3、整数集合升级的好处"></a>3、整数集合升级的好处</h4><h5 id="（1）提高灵活性"><a href="#（1）提高灵活性" class="headerlink" title="（1）提高灵活性"></a>（1）提高灵活性</h5><p>​因为 C 语言是静态类型语言，无法使用同一类型的数组来保存不同类型的数据，例如 int16_t 的数组只能保存 int16_t 的数据，保存不了 int32_t 的数据，会提示类型错误。</p><p>​整数集合可以通过升级的方式，来让集合保存三种不同类型的数据，这样就不用担心出现类型错误的问题。</p><h5 id="（2）节约内存"><a href="#（2）节约内存" class="headerlink" title="（2）节约内存"></a>（2）节约内存</h5><p>​升级的做法，能够让整数集合以尽量小的空间去存储，避免浪费，只有在需要的时候才会对数组进行扩容，升级数据类型。</p><h3 id="六、压缩列表"><a href="#六、压缩列表" class="headerlink" title="六、压缩列表"></a>六、压缩列表</h3><h4 id="1、压缩列表的数据结构"><a href="#1、压缩列表的数据结构" class="headerlink" title="1、压缩列表的数据结构"></a>1、压缩列表的数据结构</h4><p>​压缩列表（ziplist）是列表键和哈希键的底层实现之一，顾名思义，压缩，它是 Redis 为了节约内存而开发出来的 <strong>顺序型数据结构</strong>，由一系列特殊编码的 <strong>连续内存块</strong> 组成，用空间换时间。</p><p>​一个压缩列表可以包含任意多个节点，每个节点可以保存一个字节数组或者一个整数值。</p><p>​下图是压缩列表在内存中的布局（<a href="https://segmentfault.com/a/1190000016901154">图片出处</a>）</p><p><img src="/2020/05/12/redis-d&a-1/image-9.png" alt="image-9"></p><div align="center" style="font-size:12px">图1-9 压缩列表的内存布局图</div><ul><li><p>压缩列表的组成（五部分）</p><ul><li><p><strong>zlbytes</strong>：整个压缩列表占用的内存大小（单位: 字节)，是一个32位无符号整数</p></li><li><p><strong>zltail</strong>：压缩列表的尾节点距离头节点的偏移量，通过它可直接确定头尾节点的地址</p></li><li><p><strong>zllen</strong>：压缩列表的节点（entry）个数，仅在该值 <strong>小于</strong> UNIT16_MAX （65535）时有效，当程序查询到该值 <strong>等于</strong> UNIT16_MAX 时就需要遍历整个压缩列表才能得到总节点数</p></li><li><p><strong>entryX</strong>：存储数据的节点，可以为字节数组或整数</p></li><li><p><strong>zlend</strong>：特殊值 0xFF （十进制为 255），用于标记压缩列表的末端</p></li></ul></li><li><p>压缩列表的节点组成（三部分）</p><ul><li><p><strong>prevlengh</strong>：记录上个节点的长度，为了方便反向遍历压缩列表，长度为 1 或 5 个字节</p><ul><li>前 8 位小于 254，表示当前面节点长度小于 254 ，占用内存为 1 个字节</li><li>前 8 位等于 254，表示前面节点长度大于或等于 254 ，这时<strong>后 32 位</strong>才是真实的长度，占用内存为 5 个字节。这里不使用 255 而使用 254 作为分界，是因为 255 是 zlend 的值，被用于判断压缩列表的末端</li></ul></li><li><p><strong>encoding</strong>：当前节点的编码规则，用来表示不同长度的字符串或整数，总共可分为 9 类，整数节点 6 类，字符串节点 3 类</p><ul><li><p>整数节点的 encoding 的长度为8位，其中<strong>高2位</strong>用来区分整数节点和字符串节点（高2位为11时是整数节点，00、01、10则是字符串节点），<strong>低6位</strong>用来区分整数节点的类型，相同 encoding 类型的<strong>整数节点</strong> data 长度是固定的</p><p><img src="/2020/05/12/redis-d&a-1/image-10.png" alt="image-10"></p><div align="center" style="font-size:12px">图1-10 压缩列表的整数节点类型图</div></li><li><p>字符串节点的 encoding 有8、16、40位三种长度，相同encoding类型的<strong>字符串节点</strong>，data长度取决于 encoding 后半部分的值。除去开头的 2 位数字，8 位长度剩下的 6 位、16 位长度剩下的 12 位都代表着 data 的实际长度，而 40 位长度则是再去掉 6 位后剩下的 32 位才代表 data 的实际长度，如下图所示。</p><p><img src="/2020/05/12/redis-d&a-1/image-11.png" alt="image-11"></p><div align="center" style="font-size:12px">图1-11 压缩列表的字符串节点类型图</div></li></ul></li><li><p><strong>data</strong>：用于存储节点真实的数据，可以是数字或字符串，不过比较特殊的是整数 1 ~ 13，因为比较短所以刚好塞在 encoding 里，这时 data 就没存数据，如图 1-10 最下面那条数据所示。</p></li></ul></li></ul><h4 id="2、连锁更新"><a href="#2、连锁更新" class="headerlink" title="2、连锁更新"></a>2、连锁更新</h4><p>​由于 prevlengh 字段会记录上一个节点的长度，当上个节点的长度小于 254 时用 1 个字节来保存，大于或等于 254 时则用 5 个字节来保存，所以当压缩列表进行新增或删除数据时，可能会出现一个这样的情况：</p><p>​前一个节点（entry1）的数据长度发生变化，从原先小于 254 变成了大于或等于 254，所以当前节点（entry2）的 prevlengh 就需要更新，从原先 1 个字节变成 5 个字节来存储。</p><p>​由于 prevlengh 是 entryX 里的一个属性，所以如果当前节点（entry2）更新后的长度从原先的小于 254 变成了大于或等于 254，那么下一个节点（entry3）又要进行更新，一直更新到某个节点的 prevlengh 字段不会从 1 个字节变成 5 个字节为止……</p><p>​这种由于单节点的增删而导致的连续多次重新分配内存的操作，被称之为 <strong>连锁更新</strong>。</p><p>​最坏情况会导致压缩列表的所有节点都重新分配内存，而每次分配内存的最坏时间复杂度为 O(n)，所以<strong>连锁更新</strong>的最坏时间复杂度为 O(n^2)。</p><p>​尽管<strong>连锁更新</strong>的时间复杂度很高，但它真正造成性能问题的概率还是比较低的，因为触发条件相对苛刻，需要满足以下2个条件：</p><ul><li><p>压缩列表中需要有<strong>多个且连续</strong>的、长度为 <strong>250 ~ 253</strong> 的节点</p></li><li><p>这种连续节点的<strong>数量要多</strong>，如果个数不多，那么并不会对性能造成多大影响</p><p>基于上述情况，压缩列表的平均时间复杂度仅为 O(n)，不用太担心连锁更新的性能问题</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> Redis设计与实现 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为何 Hashtable、ConcurrentHashMap 不允许键或值为空，而 HashMap 允许</title>
      <link href="/2020/03/20/java-collection-1/"/>
      <url>/2020/03/20/java-collection-1/</url>
      
        <content type="html"><![CDATA[<h3 id="1、底层源码实现"><a href="#1、底层源码实现" class="headerlink" title="1、底层源码实现"></a>1、底层源码实现</h3><p>HashMap 在添加空键时做了特殊处理，若key为空则哈希值为0，value 则是没判空过滤操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Hashtable 在添加空值时会直接抛空指针异常，因为要调用 key.hashCode() 方法，所以 key 也不允许为空，不然一样会抛出空指针异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="comment">// Make sure the value is not null</span></span><br><span class="line">    <span class="keyword">if</span> (value == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Makes sure the key is not already in the hashtable.</span></span><br><span class="line">    Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> key.hashCode(); <span class="comment">// key不能为空</span></span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ConcurrentHashMap 与 Hashable同理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(K key, V value, <span class="type">boolean</span> onlyIfAbsent)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="literal">null</span> || value == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、value-为不为空的限制原因"><a href="#2、value-为不为空的限制原因" class="headerlink" title="2、value 为不为空的限制原因"></a>2、value 为不为空的限制原因</h3><p>Hashtable 和 ConcurrentHashMap 都是线程安全的，使用的都是<strong>安全失败机制（fail-safe），</strong>这种机制会使你此次读到的数据不一定是最新的，但它们支持多线程操作，而 HashMap 则是线程不安全的，使用的是<strong>快速失败机制（fail-fast）</strong>，只支持单线程操作。</p><ul><li><p>fail-fast（快速失败）：在用迭代器遍历时一旦发现容器数据被修改了，立刻抛出 ConcurrentModificationException 异常，终止遍历（强一致性，不支持并发）</p></li><li><p>fail-safe（安全失败）：在用迭代器遍历时会先复制原有集合内容，随后在拷贝的集合上进行遍历，所以即使中途数据被修改了也会继续遍历下去（弱一致性，支持并发）</p></li></ul><p>所以当键值对key不为空、value为空时，这里会有一个问题：</p><div align="center" style="font-size:18px;font-weight:bold">    你如何判断 map.get(key) 取出来的值为空，是因为它值本身为空，还是因为 key 不存在，所以才返回空值的？</div><p>或许你会说，在操作前先使用 map.containsKey(key) 的方法进行判断，将它们分成两种情况即可，像下面这样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(map.containsKey(key))&#123;</span><br><span class="line">    methodA();    <span class="comment">// 若map不存在该key，则执行methodA()</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    methodB();  <span class="comment">// 若map存在该key，则执行methodB()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>但！是！</strong></p><img src="/2020/03/20/java-collection-1/1.gif" alt="img" style="zoom:45%;"><p>这种情况只适应于单线程，也就是说这三者中只适用于 HashMap ，对于 Hashtable 和ConcurrentHashMap 而言，在多线程环境下由于这个操作是非原子性的，所以 map.containsKey(key) 这个方法并不可靠。</p><p>举个例子，假设线程 1 执行这段代码，判断出map存在该key，于是打算执行 methodA() ，但它的线程在执行前被阻塞了，于是线程 1 挂起，轮到线程 2 在跑，但线程 2 接下来的操作却直接把这个 key 给删掉了，所以当又轮到线程 1 执行时，线程 1 会按照 map 依然存在该 key 的错误前提下继续执行代码，这就会引发线程的安全问题了，所以 Hashtable 和 ConcurrentHashMap 都不支持存储空值。</p><h3 id="3、key-为不为空的限制原因"><a href="#3、key-为不为空的限制原因" class="headerlink" title="3、key 为不为空的限制原因"></a>3、key 为不为空的限制原因</h3><p>emmmm，这个问题就很有意思了，我想了半天也想不出为什么，直到我在网上找到一篇文章，写到了早在 2006 年就有人在网上发出求助邮件、里面就有提到这个问题，而回答这封邮件的人里就有 JUC 包的作者 <strong>Doug Lea</strong> ，以及 HashMap 的作者之一 <strong>Josh Bloch</strong>，两个巨佬的答复中直接给出了答案：</p><div align="center"><del>他们乐意</del></div><p><img src="/2020/03/20/java-collection-1/image-20210228130138217.png" alt="image-20210228130138217"></p><p>Doug Lea 讨厌 null 值，他觉得允许 null 的设计本身就是不合理的，而 Josh Bloch 也快被他说服了，觉得这或许是个错误，但他自己也不是很确定。</p><p><del>Josh Bloch：或许是我错了但我就是不想改</del></p><p>俩人似乎讨论这个问题已经很久了……事实就是这么操蛋。</p><hr><p>顺便贴一下这篇文章出处：<a href="https://segmentfault.com/a/1190000021105716">https://segmentfault.com/a/1190000021105716</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Java集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>三、Java并发编程基础——线程</title>
      <link href="/2020/03/20/java-concurrent-3/"/>
      <url>/2020/03/20/java-concurrent-3/</url>
      
        <content type="html"><![CDATA[<h4 id="1、线程的概念"><a href="#1、线程的概念" class="headerlink" title="1、线程的概念"></a>1、线程的概念</h4><p>​进程是指一个内存中运行的应用程序，它是操作系统资源分配的最小单位。每个进程都有自己独立的一块内存空间，而一个进程中可以启动多个线程。</p><p>​线程是比进程更轻量级的调度执行单位，它是进程的一个执行单元。线程的引入可以把一个进程的资源分配和执行调度分开，各个线程之间既可以共享进程资源（内存地址、文件IO等），又可以独立调度。</p><h4 id="2、线程的实现模型"><a href="#2、线程的实现模型" class="headerlink" title="2、线程的实现模型"></a>2、线程的实现模型</h4><p>​Java 使用的是 1：1 线程模型，Python 的gevent使用的是 1：N 线程模型，而 Go 使用的是 N：M 线程模型。</p><h5 id="（1）内核线程实现（1：1实现）"><a href="#（1）内核线程实现（1：1实现）" class="headerlink" title="（1）内核线程实现（1：1实现）"></a>（1）内核线程实现（1：1实现）</h5><p>​内核线程（Kernel-Level Thread，KLT）就是由操作系统内核（Kernel）支持的线程，这种线程由内核来完成线程切换操作。</p><p>​程序一般不会直接使用内核线程（那样太危险了），而是使用内核线程的一种高级接口——轻量级进程（Light Wegiht Process，LWP）来操作内核进程。轻量级进程即我们常说的线程，由于每个轻量级线程都由一个内核线程支持，也就是说 LWP 和KLT 之间是 1：1 的关系，因此也称这种模型为一对一的线程模型。</p><p>​这类似于一种代理模式，LWP 就是代理对象，而 KLT 则是被代理对象，我们把任务请求发给代理人 LWP，然后 LWP 会通过调用真实具备执行任务能力的被代理人 KLT 去执行任务。</p><p><img src="/2020/03/20/java-concurrent-3/clipboard-1613641813843.png" alt="img"></p><div align="center" style="font-size:12px">图3-1 轻量级进程与内核线程之间1：1的关系图</div><ul><li><p><strong>优点</strong>：</p></li><li><ul><li>每个 LWP 都是一个独立的调度单元，即便有一个 LWP 在系统调用中被阻塞了，也不会影响整个进程继续工作，系统的稳定性会比较好。</li><li>线程的调度和各种操作都委托给了操作系统，所以实现上比较简单。</li></ul></li><li><p><strong>缺点</strong>：</p></li><li><ul><li>各种线程操作（创建、析构、同步等）都需要进行系统调用，而系统调用的代价较高，需要在<strong>用户态</strong>和<strong>内核态</strong>中来回切换，这需要消耗掉一定时间。</li><li>每个 LWP 都需要一个 KLT 支持，即每个 LWP 都会消耗掉一部分内核资源（例如内核线程的栈空间），因此系统可以支持的 LWP 数量是有限的。</li></ul></li></ul><h5 id="（2）用户线程实现（1：N实现）"><a href="#（2）用户线程实现（1：N实现）" class="headerlink" title="（2）用户线程实现（1：N实现）"></a>（2）用户线程实现（1：N实现）</h5><p>​广义上讲，一个线程只要不是 KLT ，都可以认为是用户线程（User Thread，UT）的一种。</p><p>​狭义上讲， UT 指的是完全建立在用户空间的线程，即操作系统感知不到线程的存在，只知道那个掌控着这些 UT 的进程 P 。因此，进程和 UT 之间的比例是 1：N 。</p><p><img src="/2020/03/20/java-concurrent-3/clipboard-1613641836218.png" alt="img"></p><div align="center" style="font-size:12px">图3-2 进程与用户线程之间1：N的关系图</div><ul><li><p><strong>优点</strong>：</p></li><li><ul><li>UT 的创建、同步、销毁、调度都是在用户态完成的，完全不需要切换到内核态，因此各种线程操作可以非常快速且低消耗。</li><li>由于进程和 UT 之间的比例为 1：N，所以可以支持更大规模的 UT 数量，部分高性能数据库中的多线程就是由 UT 实现的。</li></ul></li><li><p><strong>缺点</strong>：</p></li><li><ul><li>由于没有系统内核的支持，所以所有的线程操作都需要程序自己实现，这就使得 UT 的实现程序通常都比较复杂，甚至有些是不可能实现的。</li></ul></li></ul><blockquote><p>现在使用 UT 的程序越来越少了，Java 和 Ruby 等语言都曾使用过 UT ，但最终又放弃了，而 Golang 、 Erlang 等以高并发为卖点的新语言则普遍支持了 UT 。</p></blockquote><h5 id="（3）用户线程加轻量级进程混合实现（N：M实现）"><a href="#（3）用户线程加轻量级进程混合实现（N：M实现）" class="headerlink" title="（3）用户线程加轻量级进程混合实现（N：M实现）"></a>（3）用户线程加轻量级进程混合实现（N：M实现）</h5><p>​这种混合模式下，既存在 UT ，也存在 KLT ，被称之为 N：M 实现。</p><p><img src="/2020/03/20/java-concurrent-3/clipboard-1613641867631.png" alt="img"></p><div align="center" style="font-size:12px">图3-3 用户线程与轻量级进程之间N：M的关系图</div><p>该实现模型有以下特点：</p><ul><li>UT 还是完全建立在用户空间中，因此线程的创建、切换、析构等消耗依旧很小，同时也可以支持大规模的 UT 并发。</li><li>对于线程的调度，则使用 LWP 作为 UT 和 KLT 之间的桥梁，这样可以使用操作系统提供的线程调度功能和处理器映射了。</li><li>UT 的系统调用要通过 LWP 来完成，大大降低了整个进程被完全阻塞的风险。</li><li>UT 和 LWP 之间的数量比是不定的，即两者数量是 N：M 的关系。</li></ul><blockquote><p>许多UNIX系列的操作系统，如Solaris、HP-UX等都提供了M：N的线程模型实现</p></blockquote><h4 id="3、线程的调度"><a href="#3、线程的调度" class="headerlink" title="3、线程的调度"></a>3、线程的调度</h4><p>​线程调度是指系统为线程分配处理器使用权的过程，调度主要方式有两种，分别是协同式（Cooperative Threads-Scheduling）线程调度和抢占式（Preemptive Threads-Scheduling）线程调度。</p><ul><li><p><strong>协同式线程调度</strong>： 线程的执行时间由线程本身来控制，线程执行完自己的任务之后，主动通知系统切换到另一个线程。</p></li><li><ul><li>优点： 实现简单，切换操作对于线程自己可知，一般没有线程同步的问题。</li><li>缺点： 线程执行时间不可控，如果一个线程编写有问题而一直不告知系统进行线程切换，程序会一直阻塞在那里。</li></ul></li><li><p><strong>抢占式线程调度</strong>： 每个线程由系统分配执行时间，线程的切换不由程序本身来决定，而是由系统决定。</p></li><li><ul><li>优点： 线程执行时间可控，不会因一个线程出错而耽误整个进程乃至系统。</li></ul></li><li><ul><li>缺点： 存在线程同步的问题，并且线程切换控制比较复杂。</li></ul></li><li><ul><li>Java 使用的线程调度方式就是这种。</li></ul></li></ul><h4 id="4、线程的生命周期状态"><a href="#4、线程的生命周期状态" class="headerlink" title="4、线程的生命周期状态"></a>4、线程的生命周期状态</h4><h5 id="（1）通用的线程生命周期"><a href="#（1）通用的线程生命周期" class="headerlink" title="（1）通用的线程生命周期"></a>（1）通用的线程生命周期</h5><p>​通用的线程生命周期模型主要将线程的状态分为以下五种：</p><ul><li><strong>初始：</strong>线程从创建到被cpu执行之前的这个阶段。这个状态下的线程仅仅是在编程语言层面被创建，而在操作系统层面并没有被创建，因此还不能被分配CPU资源，这相当于Java中new了个Thread对象但还没调用 start() 方法。</li><li><strong>就绪：</strong>指线程可以分配cpu执行。在这种状态下，真正的操作系统线程已经被成功创建了，所以可以分配 CPU 执行。</li><li><strong>运行：</strong>表示线程正获得cpu在运行。当有空闲的CPU资源时，操作系统会将资源分配给处于就绪状态的线程，这时线程的状态就将转为运行状态</li><li><strong>阻塞：</strong>指线程在执行中因某件事而受阻，处于暂停执行的状态，并且放弃自己的CPU使用权。当它的阻塞状态结束了，它的状态会变为就绪状态，等待再次被分配 CPU 资源。</li><li><strong>终止：</strong>当线程执行完或出现异常时，它就会进入终止状态，不会再切换到其他任何状态，这也意味着线程的生命周期结束了。</li></ul><p><img src="/2020/03/20/java-concurrent-3/clipboard-1613641890655.png" alt="img"></p><div align="center" style="font-size:12px">图3-4 通用的线程生命周期图</div><h5 id="（2）Java-的线程生命周期"><a href="#（2）Java-的线程生命周期" class="headerlink" title="（2）Java 的线程生命周期"></a>（2）Java 的线程生命周期</h5><p>​Java语言中线程共有六种状态：</p><ul><li><strong>新建（New）</strong>：创建后尚未启动的线程处于这种状态。</li><li><strong>运行（Runnable）</strong>：包含操作系统线程状态中的就绪和运行状态，处于该状态的线程可能正在执行，也可能在等待着操作系统为它分配CPU资源。</li><li><strong>等待（Waiting）</strong>：处于这种状态的线程不会被分配CPU资源，它们要等待被其他线程显式唤醒。</li><li><strong>超时等待（Timed Waiting）</strong>：处于这种状态的线程不会被分配CPU资源，不过在一定时间之后，即使不被其他线程显示唤醒，也会由操作系统自动唤醒。</li><li><strong>阻塞（Blocked）</strong>：线程被阻塞了，“阻塞状态”与“等待状态”的区别是“阻塞状态”在等待着获取到一个排它锁，这个事件将在另外一个线程放弃这个锁的时候发生；而“等待状态”则是在等待一段时间，或者唤醒动作的发生。</li><li><strong>结束（Terminated）</strong>：已终止线程的线程状态，线程已经结束执行。</li></ul><p><img src="/2020/03/20/java-concurrent-3/clipboard-1613641912554.png" alt="img"></p><div align="center" style="font-size:12px">图3-5 Java线程的生命周期图</div><h4 id="5、Java-多线程的实现方式"><a href="#5、Java-多线程的实现方式" class="headerlink" title="5、Java 多线程的实现方式"></a>5、Java 多线程的实现方式</h4><h5 id="（1）继承-Thread-类"><a href="#（1）继承-Thread-类" class="headerlink" title="（1）继承 Thread 类"></a>（1）继承 Thread 类</h5><p>​Java 中提供了一个 java.lang.Thread 的程序类，底层是继承了Runnable接口的实现类。一个类只需要继承此类就表示此类为线程的主体，再覆写一个run()方法，就可以使用start()方法启动线程了。</p><p>​选择继承Thread类实现多线程的缺点是扩展性差，因为Java程序只允许单继承一个类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;<span class="comment">//线程主体类</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyThread</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;<span class="comment">//线程的主体方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;test: &quot;</span> + <span class="built_in">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​任何情况下，只要定义了多线程，那么多线程的启动永远只有一种方法，即Thread类的start()方法。</p><h5 id="（2）实现-Runnable-接口"><a href="#（2）实现-Runnable-接口" class="headerlink" title="（2）实现 Runnable 接口"></a>（2）实现 Runnable 接口</h5><p>​一般情况下多线程多采用实现java.lang.Runnable接口的方式实现，因为这样做不会有单继承的局限性，扩展性更佳，不过启动时还是需要通过Thread类实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;<span class="comment">//线程主体类</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyThread</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;<span class="comment">//线程的主体方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;test: &quot;</span> + <span class="built_in">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">threadA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">MyThread</span>(<span class="string">&quot;线程A&quot;</span>));</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">threadB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">MyThread</span>(<span class="string">&quot;线程B&quot;</span>));</span><br><span class="line">        threadA.start();</span><br><span class="line">        threadB.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="（3）实现-Callable-接口"><a href="#（3）实现-Callable-接口" class="headerlink" title="（3）实现 Callable 接口"></a>（3）实现 Callable 接口</h5><p>​如果当线程执行完毕时，需要获取它的返回值，那么就可以采用Callable接口实现多线程（Runnable接口的线程无返回值）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Callable接口的源码</span><br><span class="line"></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Callable</span>&lt;V&gt; &#123;</span><br><span class="line"> <span class="keyword">public</span> V <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​Callbale定义的时候可以设置一个泛型，此泛型的类型就是返回数据的类型，这样的的好处是可以避免向下转行所带来的安全隐患。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;String&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span> ; x &lt; <span class="number">10</span> ; x ++ ) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;thread work，x = &quot;</span> + x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;finished&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">FutureTask</span> <span class="variable">futureTask</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FutureTask</span>(<span class="keyword">new</span> <span class="title class_">MyThread</span>());</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask).start();</span><br><span class="line">        System.out.println(<span class="string">&quot;thread return：&quot;</span> + futureTask.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Runnable 与 Callable的区别：</strong></p><ul><li><p>Runnable是在JDK1.0的时候提出的多线程的实现接口，而Callable是在JDK1.5之后提出的；</p></li><li><p>java.lang.Runnable 接口之中只提供了一个run（）方法，并且没有返回值；</p></li><li><p>java.util.concurrent.Callable接口提供有call()，可以有返回值；</p></li></ul><h4 id="6、启动与终止线程的方法"><a href="#6、启动与终止线程的方法" class="headerlink" title="6、启动与终止线程的方法"></a>6、启动与终止线程的方法</h4><p>​启动线程是调用线程类的start()方法即可，但终止线程不能使用stop()方法，因为它在终止线程时不会保证占用得线程资源会被正常释放。</p><p>​suspend()方法是暂停线程，线程进入休眠时也不会释放被占用的资源。</p><p>​比较安全地终止线程的方法是设置控制信号变量，或者使用 interrup() 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Shutdown</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Runner</span> <span class="variable">one</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runner</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">countThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(one, <span class="string">&quot;CountThread&quot;</span>);</span><br><span class="line">        countThread.start();</span><br><span class="line">        <span class="comment">// 睡眠1秒，main线程对CountThread进行中断，使CountThread能够感知中断而结束</span></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        countThread.interrupt();</span><br><span class="line">        <span class="type">Runner</span> <span class="variable">two</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runner</span>();</span><br><span class="line">        countThread = <span class="keyword">new</span> <span class="title class_">Thread</span>(two, <span class="string">&quot;CountThread&quot;</span>);</span><br><span class="line">        countThread.start();</span><br><span class="line">        <span class="comment">// 睡眠1秒，main线程对Runner two进行取消，使CountThread能够感知on为false而结束</span></span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        two.cancel();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Runner</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">long</span> i;</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">on</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (on &amp;&amp; !Thread.currentThread().isInterrupted())&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;Count i = &quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cancel</span><span class="params">()</span> &#123;</span><br><span class="line">            on = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>四、Java并发编程——Java中的锁</title>
      <link href="/2020/03/20/java-concurrent-4/"/>
      <url>/2020/03/20/java-concurrent-4/</url>
      
        <content type="html"><![CDATA[<h3 id="1、CAS操作"><a href="#1、CAS操作" class="headerlink" title="1、CAS操作"></a>1、CAS操作</h3><h4 id="（1）简介"><a href="#（1）简介" class="headerlink" title="（1）简介"></a>（1）简介</h4><p>CAS（compareAndSwap）是一种无锁的非阻塞算法的实现，它是一条原子指令，乐观锁的使用的机制就是CAS。</p><h4 id="（2）原理"><a href="#（2）原理" class="headerlink" title="（2）原理"></a>（2）原理</h4><p>在CAS方法中，CAS有三个操作数，内存值V，旧的预期值E，要修改的新值U。当且仅当预期值E和内存值V相等时，将内存值V修改为U，否则什么都不做。</p><h4 id="（3）作用"><a href="#（3）作用" class="headerlink" title="（3）作用"></a>（3）作用</h4><p>于CAS是一种无锁的非阻塞的算法实现，所以在线程数不多（并发量小）的情况下，它的性能要比synchronized()要高得多，但是如果线程数过多（并发量大）就会过分的消耗CPU资源，这时采用加锁的方法保证线程安全会比较妥当。</p><p>例如AtomicInteger的原子类，底层调用的是Unsafe类里的方法，如下面的Add方法，倘若有多个线程都在修改同一个数据，频繁变化的数据会导致 <strong>this.compareAndSwapInt(var1, var2, var5, var5 + var4)</strong> 方法一直没成功而不断重试，进而不断消耗CPU资源。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndAddInt</span><span class="params">(Object var1, <span class="type">long</span> var2, <span class="type">int</span> var4)</span> &#123;</span><br><span class="line">    <span class="type">int</span> var5;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        var5 = <span class="built_in">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">    &#125; <span class="keyword">while</span>(!<span class="built_in">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> var5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="（4）ABA-问题与解决方法"><a href="#（4）ABA-问题与解决方法" class="headerlink" title="（4）ABA 问题与解决方法"></a>（4）ABA 问题与解决方法</h4><ul><li>问题描述：如果另一个线程修改V值假设原来是A，先修改成B，再修改回成A。当前线程的 CAS 操作无法分辨当前V值是否发生过变化。</li><li>解决方法：对内存中的值加个版本号，在比较的时候除了比较值以外，还比较版本号。Java中 AtomicStampedReference 就是用版本号实现 CAS 机制。</li></ul><h3 id="2、Synchronized锁"><a href="#2、Synchronized锁" class="headerlink" title="2、Synchronized锁"></a>2、Synchronized锁</h3><h4 id="（1）简介-1"><a href="#（1）简介-1" class="headerlink" title="（1）简介"></a>（1）简介</h4><p>synchronized 是 Java 的一个关键字，用它来修饰代码块（方法），能够将代码块（方法）锁起来。</p><p>它主要作用是确保多个线程在同一个时刻，只能有一个线程处于方法或者同步块中。它保证了其他线程对变量的<strong>可见性</strong>（被修饰的代码块是一次性执行，没有其他线程同时访问）和线程对变量操作的<strong>原子性</strong>（执行完 synchronized 后，修改后的变量对其他线程可见），从而保证了并发下的线程安全。</p><p><img src="/2020/03/20/java-concurrent-4/clipboard-1614670869116.png" alt="img"></p><div align="center" style="font-size:12px">图4-1 synchronized 锁思维导图</div><h4 id="（2）特性"><a href="#（2）特性" class="headerlink" title="（2）特性"></a>（2）特性</h4><ul><li>有序性：通过 as-if-serial 和 Happens-Before 规则来保证</li><li>可见性：强制工作内存刷新</li><li>原子性：单一线程持有</li><li>可重入性：JVM 程序计数器来记录重入次数</li><li>不可中断性：一个线程获取锁后，没获取锁的线程会一直处于阻塞或等待状态，不可被中断（Lock 的 tryLock 方法则可以被中断）</li></ul><h4 id="（3）原理"><a href="#（3）原理" class="headerlink" title="（3）原理"></a>（3）原理</h4><p>JVM 是通过进入、退出对象监视器（Monitor）来实现对方法、同步块的同步的。</p><p>具体实现是在编译之后在同步方法调用前加入一个 <strong>monitorenter</strong> 指令，在退出方法和异常处插入 <strong>monitorexit</strong> 的指令。</p><p>其本质就是对一个对象监视器 Monitor 进行获取，而这个获取过程具有排他性从而达到了同一时刻只能一个线程访问的目的。而对于没有获取到锁的线程将会阻塞到方法入口处，直到获取锁的线程 monitorexit 之后才能尝试继续获取锁。</p><p>如果是修饰代码块的话，Synchronized 底层是采用的就是上面这种方法，但如果是修饰方法的话，底层是采用方法修饰符上的<strong>ACC_SYNCHRONIZED</strong> 实现。</p><p>代码例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (Synchronize.class)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Synchronize&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例子对应的字节码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">com</span>.crossoverjie.synchronize.Synchronize &#123;</span><br><span class="line">  <span class="keyword">public</span> com.crossoverjie.synchronize.Synchronize();</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       <span class="number">1</span>: invokespecial #<span class="number">1</span>                  <span class="comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">       <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(java.lang.String[])</span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: ldc           #<span class="number">2</span>                  <span class="comment">// class com/crossoverjie/synchronize/Synchronize</span></span><br><span class="line">       <span class="number">2</span>: dup</span><br><span class="line">       <span class="number">3</span>: astore_1</span><br><span class="line">       **<span class="number">4</span>: monitorenter**</span><br><span class="line">       <span class="number">5</span>: getstatic     #<span class="number">3</span>                  <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">       <span class="number">8</span>: ldc           #<span class="number">4</span>                  <span class="comment">// String Synchronize</span></span><br><span class="line">      <span class="number">10</span>: invokevirtual #<span class="number">5</span>                  <span class="comment">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="line">      <span class="number">13</span>: aload_1</span><br><span class="line">      **<span class="number">14</span>: monitorexit**</span><br><span class="line">      <span class="number">15</span>: goto          <span class="number">23</span></span><br><span class="line">      <span class="number">18</span>: astore_2</span><br><span class="line">      <span class="number">19</span>: aload_1</span><br><span class="line">      <span class="number">20</span>: monitorexit</span><br><span class="line">      <span class="number">21</span>: aload_2</span><br><span class="line">      <span class="number">22</span>: athrow</span><br><span class="line">      <span class="number">23</span>: <span class="keyword">return</span></span><br><span class="line">    Exception table:</span><br><span class="line">       from    to  target type</span><br><span class="line">           <span class="number">5</span>    <span class="number">15</span>    <span class="number">18</span>   any</span><br><span class="line">          <span class="number">18</span>    <span class="number">21</span>    <span class="number">18</span>   any</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>问题：为何解析出来的字节码中会有两个 monitorexit ？</strong></p><p>之所以会出现两个 monitorexit ，是因为同步代码块添加了一个隐式的 try-finally，为了防止因代码执行异常而出现死锁现象。</p><p>第一个 monitorexit 指令是正常释放锁的一个标志，若遇到了 Exception 或 Error 异常，则会调用第二个 monitorexit 指令来保证锁的释放，不会两个同时调用。</p><h4 id="（4）锁优化"><a href="#（4）锁优化" class="headerlink" title="（4）锁优化"></a>（4）锁优化</h4><p>JDK 1.6 开始，JVM 对 Synchronized 做了各种优化，引入了偏向锁和轻量级锁，还做了适应自旋锁、锁消除和锁粗化等处理。</p><ul><li><p><strong>锁消除</strong>：在编译期间有一种优化叫做逃逸分析，如果证明一个对象不会逃逸到方法外，即该对象不会被当前方法外的其他任何地方访问到，那么就可针对该对象进行优化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClearLock</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();<span class="comment">//对象无逃逸</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">new</span> <span class="title class_">Object</span>()) &#123;<span class="comment">//对象无逃逸，此处可以优化删除synchronized</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>锁粗化</strong>：如果发现有对同一对象连续的加锁、解锁操作，那么可将锁扩大到几步连续操作的最外面，即粗化锁的范围，借此减少多次加解锁带来的性能消耗。例如下面的方法 mthodA 可以被粗化成 mthodB 的样子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">methodA</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">        <span class="comment">//do something 1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">        <span class="comment">//do something 2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">methodB</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">        <span class="comment">//do something 1</span></span><br><span class="line">        <span class="comment">//do something 2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>synchronized 锁的升级完整流程图，如下所示</p><p><img src="/2020/03/20/java-concurrent-4/clipboard.png" alt="img"></p><div align="center" style="font-size:12px">图4-2 synchronized 锁升级流程图</div><h3 id="3、Lock-接口"><a href="#3、Lock-接口" class="headerlink" title="3、Lock 接口"></a>3、Lock 接口</h3><h4 id="（1）简介-2"><a href="#（1）简介-2" class="headerlink" title="（1）简介"></a>（1）简介</h4><p>在Lock接口出现之前，Java 程序是靠 synchronized 关键字实现锁功能的，而 JDK 1.5 之后，JUC 包中新增了 Lock 接口（以及相关实现类）用来实现锁功能。它提供了与 synchronized 关键字类似的同步功能，只是在使用时需要显式地获取和释放锁。</p><p>Lock 的常见实现类有重入锁（ReentrantLock）、读锁（ReadLock）、写锁（WriteLock），其底层基本都是依靠 AbstractQueuedSynchronized（简称 AQS ）的实现类来完成。</p><h4 id="（2）特性-1"><a href="#（2）特性-1" class="headerlink" title="（2）特性"></a>（2）特性</h4><table><thead><tr><th>特性</th><th>描述</th></tr></thead><tbody><tr><td>尝试非阻塞地获取锁</td><td>当前线程尝试获取锁，如果这一时刻锁没有被其他线程获取到，则成功获取并持有锁</td></tr><tr><td>能被中断地获取锁</td><td>与synchronized不同，获取到的锁能够响应中断，当获取到锁的线程被中断时，中断异常将会被抛出，同时锁会被释放</td></tr><tr><td>超时获取锁</td><td>在指定的时间截止之前获取锁，如果截止时间之前仍旧无法获取锁，则返回</td></tr></tbody></table><h3 id="4、队列同步器-AQS"><a href="#4、队列同步器-AQS" class="headerlink" title="4、队列同步器 AQS"></a>4、队列同步器 AQS</h3><h4 id="（1）简介-3"><a href="#（1）简介-3" class="headerlink" title="（1）简介"></a>（1）简介</h4><p>Java并发包（JUC）中提供了很多并发工具，这其中，很多我们耳熟能详的并发工具，譬如 ReentrantLock、Semaphore，它们的实现都用到了一个共同的基类—— AbstractQueuedSynchronizer，简称 AQS 。</p><h4 id="（2）实现原理"><a href="#（2）实现原理" class="headerlink" title="（2）实现原理"></a>（2）实现原理</h4><p>AQS 是一个用来构建锁和同步器的基础框架，它使用了一个 volatile int state 成员变量表示同步状态，通过内置的 FIFO 队列来完成资源获取线程的排队工作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> state;<span class="comment">//共享变量，使用volatile修饰保证线程可见性</span></span><br></pre></td></tr></table></figure><p>状态信息通过protected类型的 getState，setState，compareAndSetState 进行操作。</p><p>这里volatile能够保证多线程下的可见性，当 state&#x3D;1 则代表当前对象锁已经被占有，其他线程来加锁时则会失败，加锁失败的线程会被放入一个FIFO的等待队列中，比列会被UNSAFE.park()操作挂起，等待其他获取锁的线程释放锁才能够被唤醒。</p><p><img src="/2020/03/20/java-concurrent-4/clipboard-1614674843402.png" alt="img"></p><div align="center" style="font-size:12px">图4-3 AQS的实现原理图</div><h4 id="（3）AQS支持的两种同步方式"><a href="#（3）AQS支持的两种同步方式" class="headerlink" title="（3）AQS支持的两种同步方式"></a>（3）AQS支持的两种同步方式</h4><p>独占式（非公平锁）：如 ReentrantLock</p><p>共享式（公平锁）：如 Semaphore、CountDownLatch</p><p>非公平锁和公平锁的区别：非公平锁性能高于公平锁性能。非公平锁可以减少CPU唤醒线程的开销，整体的吞吐效率会高点，CPU也不必取唤醒所有线程，会减少唤起线程的数量</p><p>非公平锁性能虽然优于公平锁，但是会存在导致线程饥饿的情况。在最坏的情况下，可能存在某个线程一直获取不到锁。不过相比性能而言，饥饿问题可以暂时忽略，这可能就是 ReentrantLock 默认创建非公平锁的原因之一了。</p><h3 id="5、重入锁ReentrantLock"><a href="#5、重入锁ReentrantLock" class="headerlink" title="5、重入锁ReentrantLock"></a>5、重入锁ReentrantLock</h3><h4 id="（1）简介-4"><a href="#（1）简介-4" class="headerlink" title="（1）简介"></a>（1）简介</h4><p>重入锁 ReentrantLock，顾名思义，就是支持重进入的锁，它表示该锁能够支持一个线程对资源的重复加锁。除此之外，该锁的还支持获取锁时的公平和非公平性选择。</p><h4 id="（3）ReentrantLock与Synchronized的区别"><a href="#（3）ReentrantLock与Synchronized的区别" class="headerlink" title="（3）ReentrantLock与Synchronized的区别"></a>（3）ReentrantLock与Synchronized的区别</h4><p><img src="/2020/03/20/java-concurrent-4/clipboard-1614674982576.png" alt="img"></p><div align="center" style="font-size:12px">图4-4 ReentrantLock与Synchronized的区别图</div><h3 id="6、读写锁"><a href="#6、读写锁" class="headerlink" title="6、读写锁"></a>6、读写锁</h3><h4 id="（1）简介-5"><a href="#（1）简介-5" class="headerlink" title="（1）简介"></a>（1）简介</h4><p>ReentrantLock 和 synchronized 都是排它锁，这些锁在同一时刻只允许一个线程进行访问，而读写锁在同一时刻可以允许多个读线程访问，在写线程访问的时候其他的读线程和写线程都会被阻塞。</p><p>读写锁维护一对锁(读锁和写锁)，通过锁的分离，使得并发性提高。</p><h4 id="（2）特性-2"><a href="#（2）特性-2" class="headerlink" title="（2）特性"></a>（2）特性</h4><ul><li>公平性选择：支持非公平（默认）和公平的锁获取方式，对于二者而言，非公平锁的吞吐量要优于公平锁</li><li>可重入：读线程获取读锁之后能够再次获取读锁；写线程获取写锁之后能再次获取写锁，也可以获取读锁</li><li>锁能降级：遵循获取写锁、获取读锁在释放写锁的顺序，即写锁能够降级为读锁，但不支持锁升级</li></ul><h3 id="7、LockSupport"><a href="#7、LockSupport" class="headerlink" title="7、LockSupport"></a>7、LockSupport</h3><h4 id="（1）简介-6"><a href="#（1）简介-6" class="headerlink" title="（1）简介"></a>（1）简介</h4><p>LockSupport 类，是 JUC 包中的一个工具类，是用来创建锁和其他同步类的基本线程阻塞，底层依赖于 Unsafe 类实现。</p><p>LockSupport类的核心方法是 park() 和 unpark()，其中 park() 方法用来阻塞当前调用线程，unpark() 方法用于唤醒指定线程。</p><h4 id="（2）解析"><a href="#（2）解析" class="headerlink" title="（2）解析"></a>（2）解析</h4><p>每个使用 LockSupport 的线程都会与一个许可（permit）关联，如果该许可可用，则调用 park() 将会立即返回。如果许可尚不可用，则可以调用 unpark() 使其可用，否则可能阻塞。</p><p>调用 park() 后会阻塞当前线程，但以下三种情况都可以解除阻塞，令其继续执行：</p><ul><li>其他线程将当前线程作为目标调用 unpark()</li><li>其他线程中断当前线程 interrupt()</li><li>该调用不合逻辑（毫无理由）地返回</li></ul><h3 id="8、Condition接口"><a href="#8、Condition接口" class="headerlink" title="8、Condition接口"></a>8、Condition接口</h3><h4 id="（1）简介-7"><a href="#（1）简介-7" class="headerlink" title="（1）简介"></a>（1）简介</h4><p>Condition 是在 Java 1.5 才出现的，它用来替代传统的Object的wait()、notify()实现线程间的协作。相比使用Object的wait()、notify()，使用 Condition 中的await()、signal()这种方式实现线程间协作更加安全和高效，因此通常来说比较推荐使用 Condition。</p><p>Condition 主要与 Lock 进行配合，获取一个 Condition 对象需要调用 Lock 的 newCondition 方法或得 ConditionObject，是AQS的一个内部类。</p><h4 id="（2）实现原理与案例"><a href="#（2）实现原理与案例" class="headerlink" title="（2）实现原理与案例"></a>（2）实现原理与案例</h4><p>一个线程获取锁后，通过调用Condition的await()方法，会释放锁，然后构造成节点并将节点从尾部加入等待队列,并进入等待状态。</p><p>当线程调用 signal() 方法后，程序首先检查当前线程是否获取了锁，然后通过 doSignal(Node first) 方法唤醒同步队列的等待时间最长的节点（首节点)。在唤醒节点之前，会将节点移动到同步队列中，被唤醒的线程，将从 await() 方法中的while循环中退出来，然后调用 acquireQueued() 方法竞争同步状态。</p><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ReentrantLock 实现源码学习</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 一枝花算不算浪漫</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/4/28 7:20</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReentrantLockDemo</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Condition</span> <span class="variable">condition</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程一加锁成功&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;线程一执行await被挂起&quot;</span>);</span><br><span class="line">                condition.await();</span><br><span class="line">                System.out.println(<span class="string">&quot;线程一被唤醒成功&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">                System.out.println(<span class="string">&quot;线程一释放锁成功&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程二加锁成功&quot;</span>);</span><br><span class="line">                condition.signal();</span><br><span class="line">                System.out.println(<span class="string">&quot;线程二唤醒线程一&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">                System.out.println(<span class="string">&quot;线程二释放锁成功&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行效果如下：</p><p><img src="/2020/03/20/java-concurrent-4/clipboard-1614675272036.png" alt="img"></p><div align="center" style="font-size:12px">图4-5 Condition示例代码执行结果图</div><p>代码执行流程如下：</p><p><img src="/2020/03/20/java-concurrent-4/clipboard-1614675286650.png" alt="img"></p><div align="center" style="font-size:12px">图4-6 Condition示例代码执行流程图</div><h4 id="（3）Condition-与-await-x2F-notify-的比较"><a href="#（3）Condition-与-await-x2F-notify-的比较" class="headerlink" title="（3）Condition 与 await&#x2F;notify 的比较"></a>（3）Condition 与 await&#x2F;notify 的比较</h4><ul><li>Condition 可以精准的对多个不同条件进行控制，wait&#x2F;notify 只能和 synchronized 关键字一起使用，并且只能唤醒一个或者全部的等待队列；</li><li>Condition 需要使用 Lock 进行控制，使用的时候要注意 lock() 后及时的unlock()，Condition 有类似于 await 的机制，因此不会产生加锁方式而产生的死锁出现，同时底层实现的是 park&#x2F;unpark 的机制，因此也不会产生先唤醒再挂起的死锁，一句话就是不会产生死锁，但是 wait&#x2F;notify 会产生先唤醒再挂起的死锁。</li></ul><hr>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二、Java并发编程基础——Java内存模型（JMM）</title>
      <link href="/2020/03/17/java-concurrent-2/"/>
      <url>/2020/03/17/java-concurrent-2/</url>
      
        <content type="html"><![CDATA[<h4 id="1、硬件的利用效率与一致性"><a href="#1、硬件的利用效率与一致性" class="headerlink" title="1、硬件的利用效率与一致性"></a>1、硬件的利用效率与一致性</h4><p>​由于计算机的存储设备与处理器的运算速度相差好几个数量级，CPU经常需要等待主存，白白浪费资源，所以现代计算机加入一层或多层读写速度尽可能接近处理器运算速度的<strong>高速缓存（Cache）</strong>来作为内存与处理器之间的缓冲 ( 结构 : cpu -&gt; cache -&gt; memory ) 。</p><p>​这种CPU多级缓存的方式很好地解决了CPU与内存速度之间的矛盾，但也引入了一个新的问题：<strong>缓存一致性（Cache Coherence）</strong>。为了解决一致性问题，各个处理器在访问缓存以及读写时都需要遵循一些协议，这类协议有MSI、<strong>MESI</strong>（Illinois Protocol）、MOSI、Synapse、Firefly及Dragon Protocol等。</p><p>​除了增加高速缓存外，为了提高硬件的利用率，处理器还可能会对输入代码进行<strong>乱序执行（Out-Of-Order Execution）</strong>优化，即保证最终结果与顺序执行的一致，但不保证程序中每个语句计算的先后顺序，类似于 <code>JVM</code> 中的指令重排序优化。</p><h4 id="2、主内存与工作内存"><a href="#2、主内存与工作内存" class="headerlink" title="2、主内存与工作内存"></a>2、主内存与工作内存</h4><ul><li><p>从变量、主内存、工作内存的定义来看：</p><ul><li><p>主内存主要对应于Java堆中的对象实例数据部分</p></li><li><p>工作内存则对应虚拟机栈中的部分区域</p></li></ul></li><li><p>从更基础的层次上说：</p><ul><li>主内存直接对应于物理硬件的内存</li><li>为了获取更好的运行速度，虚拟机（或是硬件、操作系统本身的优化措施）可能会让工作内存优先存储于寄存器和高速缓存中，因为程序运行时主要访问的是工作内存。</li></ul></li></ul><p>​JMM 规定了所有的变量都存储在主内存中，每个线程都有自己的工作内存，线程的工作内存中保存的是当前线程使用到的变量值的副本（从主内存拷贝过来的）。</p><p>​线程对变量的所有操作都必须在工作内存中进行，不能直接读写主内存中的数据，线程之间的相互传值也需要通过主内存来完成。</p><p><img src="/2020/03/17/java-concurrent-2/clipboard.png" alt="img"></p><div align="center" style="font-size:12px">图2-1 线程、主内存、工作内存三者的交互关系</div><h4 id="3、八种原子操作与执行规则"><a href="#3、八种原子操作与执行规则" class="headerlink" title="3、八种原子操作与执行规则"></a>3、八种原子操作与执行规则</h4><h5 id="（1）八种原子操作"><a href="#（1）八种原子操作" class="headerlink" title="（1）八种原子操作"></a>（1）八种原子操作</h5><p>Java内存模型定义了以下 8 种操作来完成主内存与工作内存交互的工作：</p><ul><li><p>**lock (锁定)**：作用于主内存的变量。把一个变量标识为一条线程独占的状态。</p></li><li><p>**unlock (解锁)**：作用于主内存的变量.把一个处于锁定状态的变量释放出来。</p></li><li><p>**read (读取)**：作用于主内存的变量。把一个变量值从主内存传输到线程的工作内存中，以便随后的load动作使用。</p></li><li><p>**load (载入)**：作用于工作内存的变量，它把read操作从主内存中得到的值放入工作内存的变量副本中。</p></li><li><p>**use (使用)**：作用与工作内存的变量.它把工作内存中一个变量值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时就会执行这个操作。</p></li><li><p>**assign (赋值)**：作用于工作内存的变量，它把一个从执行引擎收到的赋值给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。</p></li><li><p>**store (存储)**：作用于工作内存的变量，它把工作内存中的一个变量的值传送到主内存中，以便随后的 wirte 操作使用。</p></li><li><p>**wirte (写入)**：作用于主内存的变量，它把 store 操作从工作内存中得到的变量值放入主内存中。<img src="/2020/03/17/java-concurrent-2/clipboard-1613641790425.png" alt="img"></p><div align="center" style="font-size:12px">图2-2 同步操作与规则图</div><h5 id="（2）执行规则"><a href="#（2）执行规则" class="headerlink" title="（2）执行规则"></a>（2）执行规则</h5><p>这 8 种原子操作的执行规则大致可以划分为两类，一类是有关变量拷贝过程的规则，另一类是有关加锁的规则。</p><p><strong>有关变量拷贝过程的规则</strong>：</p><ul><li>不允许 read 和 load，store 和 write 单独出现，即不允许一个变量从主内存读取了但工作内存不接受，或者工作内存发起回写了但主内存不接受的情况出现。</li><li>不允许线程丢弃它最近的 assign 操作，即变量在工作内存中改变后必须把该变化同步回主内存中。</li><li>不允许线程无原因地（没有发生过任何 assign 操作）将数据从工作内存同步回主内存中，也就是说，只有虚拟机遇到变量赋值的字节码时才会将工作内存同步回主内存。</li><li>新的变量只能从主内存中诞生，即不能在工作内存中使用未被初始化（load 或 assign）的变量，一个变量在 use 和 store 前必须先经过 load 和 assign 操作。</li></ul><p><strong>有关加锁的规则</strong>：</p><ul><li><p>一个变量在同一时刻只允许一个线程对其进行 lock 操作，但是 lock 操作可以被同一个线程多次执行（锁的可重入），多次执行后只有执行相同次数的 unlock 操作，变量才会被解锁。</p></li><li><p>对一个变量进行 lock 操作会清空这个变量在工作内存中的值，然后在执行引擎使用这个变量时，需要通过 assign 或 load 重新对这个变量进行初始化。</p></li><li><p>对一个变量执行 unlock 前，必须将该变量同步回主内存中，即执行 store 和 write 操作。</p></li><li><p>一个变量没有被 lock，就不能被 unlock，也不能去 unlock一个被其他线程 lock 的变量。</p></li></ul></li></ul><h4 id="4、as-if-serial-语义"><a href="#4、as-if-serial-语义" class="headerlink" title="4、as-if-serial 语义"></a>4、as-if-serial 语义</h4><h5 id="（1）定义"><a href="#（1）定义" class="headerlink" title="（1）定义"></a>（1）定义</h5><p>  ​as-if-serial语义的意思是不管怎么重排序（编译器和处理器为了提高并行度），（单线程）程序的执行结果不能改变。</p><p>  ​编译器、runtime和处理器都必须遵守as-if-serial语义。</p><p>  ​为了遵守as-if-serial语义，编译器和处理器不会对存在数据依赖关系的操作进行重排序，因为这种重排序会改变执行结果，但反过来说，如果不存在依赖关系则可以进行重排序。</p><h5 id="（2）as-if-serial-和-Happens-Before"><a href="#（2）as-if-serial-和-Happens-Before" class="headerlink" title="（2）as-if-serial 和 Happens-Before"></a>（2）as-if-serial 和 Happens-Before</h5><ul><li>as-if-serial语义保证单线程内程序的执行结果不被改变，happens-before关系保证正确同步的多线程程序的执行结果不被改变。</li><li>as-if-serial语义给编写单线程程序的程序员创造了一个幻境：单线程程序是按程序的顺序来执行的。</li><li>happens-before关系给编写正确同步的多线程程序的程序员创造了一个幻境：正确同步的多线程程序是按happens-before指定的顺序来执行的。</li></ul><blockquote><p>as-if-serial语义和happens-before这么做的目的，都是为了在不改变程序执行结果的前提下，尽可能地提高程序执行的并行度</p></blockquote><h4 id="5、Happens-Before-规则"><a href="#5、Happens-Before-规则" class="headerlink" title="5、Happens-Before 规则"></a>5、Happens-Before 规则</h4><h5 id="（1）由来"><a href="#（1）由来" class="headerlink" title="（1）由来"></a>（1）由来</h5><p>  ​为了提高性能，编译器和处理器常常会对指令做重排序，主要包括编译器优化的重排序、指令级并行的重排序、内存系统的重排序三部分，而源代码从开始到最终执行会依次经过这三个重排序的优化。</p><p>  ​为了避免编译优化对并发编程安全性的影响，从 JDK 5 开始 JMM 就使用 Happens-Before 规则来保证并发编程的安全性，要求编译器优化后需要满足 Happens-Before 规则。</p><h5 id="（2）定义"><a href="#（2）定义" class="headerlink" title="（2）定义"></a>（2）定义</h5><p>  ​Happens-Before，即“先行发生”规则，指的是对于不同的线程，前面的操作也应该发生在后面操作的前面，也就是说，Happens-Before 规则保证：前面的操作的结果对后面的操作一定是可见的。</p><p>  ​它上是一种顺序约束规范，用来约束编译器的优化行为，即为了执行效率，我们允许编译器的优化行为，但是为了保证程序运行的正确性，我们要求编译器优化后需要满足 Happens-Before 规则。</p><h5 id="（3）具体内容"><a href="#（3）具体内容" class="headerlink" title="（3）具体内容"></a>（3）具体内容</h5><p>  ​根据类别，我们将 Happens-Before 规则分为了以下 4 类：</p><ul><li><p>操作的顺序：</p><ul><li><strong>程序顺序规则</strong>： 如果代码中操作 A 在操作 B 之前，那么同一个线程中 A 操作一定在 B 操作前执行，即在本线程内观察，所有操作都是有序的。</li><li><strong>传递性</strong>： 在同一个线程中，如果 A 先于 B ，B 先于 C 那么 A 必然先于 C。</li></ul></li><li><p>锁和 volatile：</p><ul><li><strong>监视器锁规则</strong>： 监视器锁的解锁操作必须在同一个监视器锁的加锁操作前执行。</li><li><strong>volatile 变量规则</strong>： 对 volatile 变量的写操作必须在对该变量的读操作前执行，保证时刻读取到这个变量的最新值。</li></ul></li><li><p>线程和中断：</p><ul><li><strong>线程启动规则</strong>： Thread#start() 方法一定先于该线程中执行的操作。</li><li><strong>线程结束规则</strong>： 线程的所有操作先于线程的终结。</li><li><strong>中断规则</strong>： 假设有线程 A，其他线程 interrupt A 的操作先于检测 A 线程是否中断的操作，即对一个线程的 interrupt() 操作和 interrupted() 等检测中断的操作同时发生，那么 interrupt() 先执行。</li></ul></li><li><p>对象生命周期相关：</p><ul><li><strong>终结器规则</strong>： 对象的构造函数执行先于 finalize() 方法。</li></ul></li></ul><h4 id="6、volatile-的实现原理"><a href="#6、volatile-的实现原理" class="headerlink" title="6、volatile 的实现原理"></a>6、volatile 的实现原理</h4><h5 id="（1）简介"><a href="#（1）简介" class="headerlink" title="（1）简介"></a><strong>（1）简介</strong></h5><p>  ​volatile 是 JVM 提供的最轻量级的同步机制，它可以保证数据的 <strong>可见性</strong>，避免出现数据脏读的现象。</p><p>  ​volatile 变量是从工作内存中读取的，只是它有特殊的操作顺序规定，使得看起来像是直接在主内存中读写。</p><p>  ​每个线程操作数据的时候会把数据从主内存读取到自己的工作内存，如果他操作了数据并且写回了，那其他已经读取的线程的变量副本就会失效了（volatile底层有标记当前值是否失效的状态），需要对数据进行操作又要再次去主内存中读取了。</p><h5 id="（2）-volatile-变量的两个特点"><a href="#（2）-volatile-变量的两个特点" class="headerlink" title="（2） volatile 变量的两个特点"></a>（2） volatile 变量的两个特点</h5><p>  ​①<strong>保证对所有线程的可见性</strong></p><p>  ​这里的“可见性”指的是当一个线程修改了这个变量的值，新增对于其他线程来说是可以立即得知的。普通变量的值在线程间传递时需要通过主内存来完成，比如线程 A 修改一个普通变量的值，然后向主内存进行回写，而线程 B 在线程 A 回写完成了之后再对主内存进行读取操作，这时新变量值才会对线程 B 可见。</p><p>  ​可见性的保证是基于CPU的内存屏障指令，被JSR-133抽象为happens-before原则。</p><p>  ​②<strong>禁止指令重排序优化</strong></p><p>  ​普通变量仅会保证在该方法的执行过程中，所有依赖赋值结果的地方都能获取到正确的结果，而不能保证变量赋值操作的顺序与程序代码中的执行顺序一致。</p><p>  ​编译时JVM编译器遵循内存屏障的约束，运行时依靠CPU屏障指令来阻止重排。</p><p>  <img src="/2020/03/17/java-concurrent-2/clipboard-1614355781698.png" alt="img"></p>  <div align="center" style="font-size:12px">图2-3 volatile读写的指令图</div><h5 id="（3）-实现Happens-Before规则的要求"><a href="#（3）-实现Happens-Before规则的要求" class="headerlink" title="（3） 实现Happens-Before规则的要求"></a>（3） 实现Happens-Before规则的要求</h5><p>  ​Happens-Before 原则的规定保证了操作间的可见性，volatile 变量保证了有序性和可见性，volatile 的特性得以于Java语言中的 Happens-Before 规则。</p><p>  ​Happens-Before 规则中要求，对 volatile 变量的写操作必须在对该变量的读操作前执行，具体实现方法分两步：</p><p>  <strong>① 保证动作发生</strong></p><p>  ​首先，在对 volatile 变量进行读取和写入操作，必须去主内存拉取最新值，或是将最新值更新进主内存，不能只更新进工作内存而不将操作同步进主内存，即在执行 read、load、use、assign、store、write 操作时：</p><ul><li><p>use 操作必须与 load、read 操作同时出现，不能只 use，不 load、read。</p><ul><li>use ← load ← read</li></ul></li><li><p>assign 操作必须与 store、write 操作同时出现，不能只 assign，不 store、write。</p><ul><li>assign → store → write</li></ul></li></ul><p>  ​此时，我们已经保证了将变量的最新值时刻同步进主内存的动作发生了，接下来，我们需要保证这个动作，对于不同的线程，满足 volatile 变量的 Happens-Before 规则：<strong>对变量的写操作必须在对该变量的读操作前执行</strong>。</p><p>  <strong>② 保证动作按正确的顺序发生</strong></p><p>  ​其实，导致这个执行顺序问题的主要原因在于，这个读写 volatile 变量的操作不是一气呵成的，它并不是原子的。无论是读还是写，它都分成了 3 个命令（use ← load ← read 或 assign → store → write），这就导致了，你能保证 assignA 发生在 useB 之前，但你根本不能保证 writeA 也发生在 useB 之前，而如果 writeA 不发生在 useB 之前，主内存中的数据就是旧的，线程 B 就读不到最新值。</p><p>  ​好比一个写操作，发生在它之前的读操作可以随便执行，但是发生在它之后的读操作，必须等把 3 个命令都执行完才能执行，即 **“对变量的写操作必须在对该变量的读操作前执行” **。</p><h5 id="（4）volatile-的具体实现"><a href="#（4）volatile-的具体实现" class="headerlink" title="（4）volatile 的具体实现"></a>（4）volatile 的具体实现</h5><p>  ​Java 巧妙的利用了 lock 操作的特点，通过观察对 volatile 变量的赋值操作的反编译代码可以看出，在执行了变量赋值操作之后，额外加了一行：</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lock addl $<span class="number">0x0</span>,(%esp)</span><br></pre></td></tr></table></figure><p>  这一句的意思是：给 ESP 寄存器 +0，这是一个无意义的空操作，重点在 lock 上：</p><ul><li><p><strong>保证动作发生</strong>：</p><ul><li>lock 指令会将当前 CPU 的 Cache 写入内存，并无效化其他 CPU 的 Cache，相当于在执行了 assign 后，又进行了 store -&gt; write；</li><li>这使得其他 CPU 可以立即看见 volatile 变量的修改，因为其他 CPU 在读取 volatile 变量时，会发现自己的缓存过期了，于是会去主内存中拉取最新的 volatile 变量值，也就被迫在 use 前进行一次 read -&gt; load。</li></ul></li><li><p><strong>保证动作顺序</strong>：</p><ul><li>lock 的存在相当于一个内存屏障，使得在重排序时，不能把后面的指令排在内存屏障之前。</li></ul></li></ul><h4 id="7、final"><a href="#7、final" class="headerlink" title="7、final"></a>7、final</h4><h5 id="（1）写final域的重排序规则"><a href="#（1）写final域的重排序规则" class="headerlink" title="（1）写final域的重排序规则"></a>（1）写final域的重排序规则</h5><p>  ​写final域的重排序规则禁止把final域的写重排序到构造函数之外。</p><p>  ​该规则的实现依靠编译器在final域的写之后，构造函数return之前，插入一个StoreStore屏障。这个屏障禁止处理器把final域的写重排序到构造函数之外。</p><p>  ​写final域的重排序规则的作用：可以确保在对象引用为任意线程可见之前，对象的final域已经被正确初始化过了，而普通域不具备这个报障。</p><h5 id="（2）读final域的重排序规则"><a href="#（2）读final域的重排序规则" class="headerlink" title="（2）读final域的重排序规则"></a>（2）读final域的重排序规则</h5><p>  ​读final域的重排序规则是在一个线程中，初次读对象引用与随后初次读该对象包含的final域，JMM禁止处理器重排序这两个操作（注意该规则仅针对处理器）。</p><p>  ​该规则的实现依靠编译器在读final域操作的前面插入一个LoadLoad屏障。</p><p>  ​读final域的重排序规则的作用：可以确保在读一个对象的final域之前，一定会先读包含这个final域的对象的引用。如果引用不为null，那引用对象的final域一定已经被初始化了。</p><hr><p>  关于 volatile 详细解析：</p><p>  <a href="https://www.zhihu.com/question/31990408/answer/1028941563">https://www.zhihu.com/question/31990408/answer/1028941563</a></p><p>  <a href="https://zhuanlan.zhihu.com/p/137193948">https://zhuanlan.zhihu.com/p/137193948</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一、Java并发编程基础——预备知识</title>
      <link href="/2020/03/12/java-concurrent-1/"/>
      <url>/2020/03/12/java-concurrent-1/</url>
      
        <content type="html"><![CDATA[<h3 id="1、上下文切换"><a href="#1、上下文切换" class="headerlink" title="1、上下文切换"></a>1、上下文切换</h3><h4 id="（1）时间片"><a href="#（1）时间片" class="headerlink" title="（1）时间片"></a>（1）时间片</h4><p>​即使是单核处理器也支持多线程执行代码，CPU通过给每个线程分配CPU时间片来实现这个机制。时间片是CPU分配给每个线程的时间，由于时间片非常短，所有CPU通过不停地切换线程执行，导致我们感觉多个线程是同时执行的，时间片一般是几十毫秒（ms）。</p><h4 id="（2）上下文切换"><a href="#（2）上下文切换" class="headerlink" title="（2）上下文切换"></a>（2）上下文切换</h4><p>​CPU通过时间片分配算法来循环执行任务，当前任务执行一个时间片后就会切换到下一个任务。但是，CPU在切换前会保存上一个任务的状态，以便下次切换回该任务时能够从上次执行的位置继续执行下去。这个任务从保存到再次加载的过程就是一场上下文切换。</p><h4 id="（3）减少上下文切换的方法"><a href="#（3）减少上下文切换的方法" class="headerlink" title="（3）减少上下文切换的方法"></a>（3）减少上下文切换的方法</h4><ul><li>无锁并发编程：多线程竞争锁时，会引起上下文切换，所以多线程处理数据时，可以用一些办法来避免使用锁，例如将数据的ID按照Hash算法取模分段，不同线程处理不同段的数据。</li><li>CAS算法：Java的Atomic包使用CAS算法来更新数据，不需要加锁。</li><li>使用最少线程：避免创建不需要的线程，比如任务很少但创建了大量线程来处理，这会导致大量线程都处于等待状态。</li><li>协程：在单线程里实现多任务的调度，并在单线程里维持多个任务间的切换。</li></ul><h3 id="2、死锁"><a href="#2、死锁" class="headerlink" title="2、死锁"></a>2、死锁</h3><h4 id="（1）含义"><a href="#（1）含义" class="headerlink" title="（1）含义"></a>（1）含义</h4><p>​当两个或两个以上的线程在执行过程中，因为竞争资源而造成的一种僵局，线程相互持有对方所需的资源又不释放，若无外力作用，它们都将无法推进下去。</p><h4 id="（2）死锁产生的4个必要条件"><a href="#（2）死锁产生的4个必要条件" class="headerlink" title="（2）死锁产生的4个必要条件"></a>（2）死锁产生的4个必要条件</h4><ol><li>互斥：线程要求对所分配的资源进行排它性控制，即在一段时间内某资源仅为一线程所占用。</li><li>占有和等待：当线程因请求资源而阻塞时，对已获得的资源保持不放。</li><li>不可抢占：线程已获得的资源在未使用完之前，不能剥夺，只能在使用完时由自己释放。</li><li>循环等待：在发生死锁时，必然存在一个线程–资源的环形链。</li></ol><h4 id="（3）避免死锁的方法"><a href="#（3）避免死锁的方法" class="headerlink" title="（3）避免死锁的方法"></a>（3）避免死锁的方法</h4><ol><li>资源一次性分配：一次性分配所有资源，这样就不会再有请求了（破坏请求条件）</li><li>只要有一个资源得不到分配，也不给这个进程分配其他的资源（破坏请保持条件）</li><li>可剥夺资源：即当某进程获得了部分资源，但得不到其它资源，则释放已占有的资源（破坏不可剥夺条件）</li><li>资源有序分配法：系统给每类资源赋予一个编号，每一个进程按编号递增的顺序请求资源，释放则相反（破坏环路等待条件）</li></ol><h4 id="（4）Java避免死锁的常见方法"><a href="#（4）Java避免死锁的常见方法" class="headerlink" title="（4）Java避免死锁的常见方法"></a>（4）Java避免死锁的常见方法</h4><ol><li>避免一个线程同时获取多个锁。</li><li>避免一个线程在锁内同时占用多个资源（例如ConcurrentHashMap的实现），尽量保证每个锁只占用一个资源</li><li>尝试使用定时锁，使用lock.tryLock（timeout）来替代使用内部锁机制，一定时间内获取不到就返回。</li><li>对于数据库锁，加锁和解锁必须在同一个数据库连接里，否则会出现解锁失败的情况。</li></ol><h3 id="3、资源限制"><a href="#3、资源限制" class="headerlink" title="3、资源限制"></a>3、资源限制</h3><h4 id="（1）含义-1"><a href="#（1）含义-1" class="headerlink" title="（1）含义"></a>（1）含义</h4><p>​资源限制是指再进行并发编程时，程序的执行速度受限于计算机硬件资源或软件资源。例如，服务器的带宽只有2Mb&#x2F;s，某个资源的下载速度是1Mb&#x2F;s，即使系统启动10个线程下载资源，下载速度也不会编程10Mb&#x2F;s。</p><h4 id="（2）资源限制会引发的问题"><a href="#（2）资源限制会引发的问题" class="headerlink" title="（2）资源限制会引发的问题"></a>（2）资源限制会引发的问题</h4><p>​在并发编程中，若受限于资源，将代码从串行执行的部分改成并发执行，不仅不会加快执行速度，反而会因为增加了上下文切换和资源调度的时间，变得更慢。</p><h4 id="（3）软件资源"><a href="#（3）软件资源" class="headerlink" title="（3）软件资源"></a>（3）软件资源</h4><p>​软件资源受限有数据库的连接数、socket连接数等等。</p><p>​解决方法可以是考虑使用资源池将资源复用，例如使用连接池将数据库和socket连接复用，或者再调用对方webservice接口获取数据时，只建立一个连接。</p><h4 id="（4）硬件资源"><a href="#（4）硬件资源" class="headerlink" title="（4）硬件资源"></a>（4）硬件资源</h4><p>​硬件资源受限有带宽的下载和上传速度、硬盘读写速度、CPU处理速度等等。</p><p>​解决方法可以是考虑使用集群并发执行程序。既然单击资源有限，那就让程序在多机上运行，例如使用ODPS、Hadoop或者自己搭建服务器集群，不同机器处理不同的数据。</p><p><img src="/2020/03/12/java-concurrent-1/clipboard.png" alt="img"></p><p>​上图为《Java并发编程的艺术》的思维导图，图片出处：<a href="https://github.com/zaiyunduan123/java-concurrent-art">https://github.com/zaiyunduan123/java-concurrent-art</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>六、栈帧结构</title>
      <link href="/2019/09/18/jvm-6/"/>
      <url>/2019/09/18/jvm-6/</url>
      
        <content type="html"><![CDATA[<p><strong>1、含义</strong></p><p>JVM以方法作为最基本的执行单元，“栈帧”（Stack Frame）则是用于支持JVM进行方法调用和方法执行背后的数据结构，它也是JVM运行时数据区中的虚拟机栈的栈元素。每个方法从调用开始到执行结束的过程，都对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。</p><p>每一个栈帧都包括了局部变量表、操作数栈、动态连接、方法返回地址和一些额外的附加信息。</p><p><img src="/2019/09/18/jvm-6/clipboard.png" alt="img"></p><div align="center" style="font-size:12px">图6-1 栈帧的概念结构</div><p><strong>2、局部变量表</strong></p><ul><li>局部变量表是一组变量值的存储空间，用于存放方法参数和局部变量。在Class 文件的方法表的 Code 属性的 max_locals 指定了该方法所需局部变量表的最大容量。</li><li>局部变量表的基本单位为变量槽（Variable slot），正常来说一个slot的占用32位的长度内存，可以存放 boolean、byte、char、short、int、float、reference 和 returnAddress 8种类型，而 对于64位的 long 和 double 变量而言，虚拟机会为其分配两个连续的 Slot 空间。</li><li>JVM是通过索引定位的方式使用局部变量表，而索引值的范围是从0到最大的变量槽数量。</li><li>当调用方法是非static 方法时，局部变量表中第0位索引的 Slot 默认是用于传递方法所属对象实例的引用（reference），即 “this” 关键字指向的对象。分配完方法参数后，便会依次分配方法内部定义的局部变量。</li><li>为了节省栈帧空间，局部变量表中的 Slot 是可以复用的。因为即使是一个方法内也存在着作用域，当离开了某些变量的作用域之后，这些变量对应的 Slot 空间就可以交给其他变量使用。但是<strong>这种机制有时候会影响垃圾回收行为</strong>，原因很简单，当离开某个作用域时，如果没有新的变量值覆盖之前作用域内的变量（指reference）空间，那么当垃圾回收时，则该引用对应的java堆中的内存则不允许被回收，因为局部变量表中还存在该引用。所以问题在于虚拟机并没有主动清理局部变量表中离开作用域的变量值，而是采用新盖旧的方法被动清理。</li></ul><p><strong>3、操作数栈</strong></p><ul><li>操作数栈也被称为操作栈，用于存放下一个执行的字节码指令。在Class文件的Code属性的 max_stacks 指定了执行过程中的最大栈深度。</li><li>操作数栈的每一个元素都可以是包含long、double在内的任意Java数据类型。</li><li>32位数据类型所占的栈容量为1，64位数据类型锁占的栈容量为2。</li><li>当一个方法刚开始执行时，这个方法的操作数栈是空的，在方法的执行过程中，会有各种字节码指令向操作数栈中写入和提取内容，也就是入栈出栈的操作。</li><li>Java虚拟机的解释执行引擎称为“基于栈的执行引擎”，其中所指的“栈”就是操作数栈。<strong>如果当前线程请求的栈深度大于虚拟机所允许的最大深度，将抛出StackOverflowError异常。</strong></li><li>在概念模型中，两个栈帧是相互独立的。但是大多数虚拟机的实现都会进行优化，令两个栈帧出现一部分重叠。令下面的部分操作数栈与上面的局部变量表重叠在一块，这样在方法调用的时候可以共用一部分数据，无需进行额外的参数复制传递。</li></ul><p><img src="/2019/09/18/jvm-6/clipboard-1613628231657.png" alt="img"></p><div align="center" style="font-size:12px">图6-2 两个栈帧之间的数据共享</div><p><strong>4、动态连接</strong></p><ul><li>每个栈帧都包含一个指向当前方法所在类型的运行时常量池的引用，持有这个引用是为了支持方法调用过程中的动态连接（Dynamic Linking）。</li><li>Java源文件被编译到字节码文件中时，所有的变量和方法引用都作为符号引用(Symbolic Reference)保存在class文件的常量池里。Class 文件中存放了大量的符号引用，字节码中的方法调用指令就是以常量池中指向方法的符号引用作为参数。这些符号引用一部分会在类加载阶段或第一次使用时转化为直接引用，这种转化称为静态解析。另一部分将在每一次运行期间转化为直接引用，这部分称为动态连接。</li></ul><p><strong>5、方法返回地址</strong></p><p>当一个方法开始执行后，有两种方式可以退出当前方法。</p><ul><li>当执行引擎遇到任意一个方法返回的字节码指令（return），会将返回值传递给上层的方法调用者，这种退出方式被称之为“正常调用完成”。一般来说，方法正常退出时调用者的PC计数器可以作为返回地址，栈帧中很可能会保存这个计数器值。</li><li>当执行遇到异常，并且在当前方法体内没有得到处理，就会导致方法退出，此时是没有返回值的，这种方式被称之为“异常调用完成”。这种情况下，返回地址要通过异常处理器表来确定。</li></ul><p>本质上，方法的退出就是当前栈帧出栈的过程。此时，需要恢复上层方法的局部变量表和操作数栈、将返回值（如果有的话）压入调用者栈帧的操作数栈、调整PC寄存器的值以指向方法调用指令后面的一条指令等，让调用者方法继续执行下去。</p><p><a href="https://blog.csdn.net/dyangel2013/article/details/106588217">https://blog.csdn.net/dyangel2013/article/details/106588217</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>五、Java类加载机制</title>
      <link href="/2019/09/17/jvm-5/"/>
      <url>/2019/09/17/jvm-5/</url>
      
        <content type="html"><![CDATA[<h2 id="一、类的生命周期"><a href="#一、类的生命周期" class="headerlink" title="一、类的生命周期"></a>一、类的生命周期</h2><p><img src="/2019/09/17/jvm-5/1.png" alt="1.png"></p><div align="center" style="font-size:12px">图5-1 Java类的生命周期</div><p>​注意：解析阶段不一定按照顺序来执行，它可以在初始化阶段之后再开始，这是为了支持Java语言的运动时绑定（也称之为动态绑定或晚期绑定）</p><h2 id="二、类的初始化"><a href="#二、类的初始化" class="headerlink" title="二、类的初始化"></a>二、类的初始化</h2><h3 id="有-6-种情况会触发类的初始化"><a href="#有-6-种情况会触发类的初始化" class="headerlink" title="有 6 种情况会触发类的初始化"></a>有 6 种情况会触发类的初始化</h3><ol><li>遇到new、getstatic、putstatic或invokestatic这4条字节码指令</li><li>使用java.lang.reflect包的方法对类进行反射调用的时候</li><li>当初始化一个类的时候，若发现其父类还未初始化，则需先触发父类的初始化</li><li>当虚拟机启动时，用户需要指定一个要执行的主类（即包括main方法的那个类），虚拟机会先初始化这个类</li><li>当使用JDK 7 的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且该方法句柄所对应的类没有进行过初始化，则需要先触发其初始化</li><li>当一个接口中定义了JDK 8 新加入的默认方法（被default关键字修饰的接口方法）时，如果有该接口的实现类发生了初始化，那该接口要在其之前被初始化</li></ol><h3 id="不会触发类初始化的情况"><a href="#不会触发类初始化的情况" class="headerlink" title="不会触发类初始化的情况"></a>不会触发类初始化的情况</h3><ol><li>通过子类引用父类的静态字段，只会触发父类的初始化而不会导致子类被初始化，至于会不会触发子类的加载和验证，这个要取决于虚拟机的具体实现</li><li>通过数组定义来引用类，不会触发此类的初始化，例如 Test[] test &#x3D; new Test[450]</li><li>引用一个类的常量也不会触发类的初始化，因为常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类</li></ol><h2 id="三、生命周期具体过程"><a href="#三、生命周期具体过程" class="headerlink" title="三、生命周期具体过程"></a>三、生命周期具体过程</h2><h3 id="1、加载"><a href="#1、加载" class="headerlink" title="1、加载"></a>1、加载</h3><p>​该阶段虚拟机要完成三件事</p><ol><li>通过一个类的全定名来获取定义此类的二进制字节流（不一定要从一个Class文件中获取，也可以从ZIP包、网络、动态生成、数据库等渠道获取）</li><li>将这个字节流的二进制内容加载到虚拟机的方法区</li><li>在内存中生成一个java.lang.Class对象，作为方法区这个类的各种数据的访问入口</li></ol><p>&amp;emsp;&amp;emsp;相对于类加载的其他阶段而言，加载阶段（准确地说，是加载阶段获取类的二进制字节流的动作）是可控性最强的阶段，因为开发人员既可以使用系统提供的类加载器来完成加载，也可以自定义自己的类加载器来完成加载。</p><blockquote><p>注意：加载阶段与连接阶段的部分内容（如一部分字节码文件格式验证动作）是交叉进行的，加载阶段尚未完成，连接阶段可能就开始了，但这些夹在加载阶段之中进行的动作，仍然属于连接阶段的内容，这两个阶段的开始时间仍然保持着固定的先后顺序</p></blockquote><h3 id="2、验证"><a href="#2、验证" class="headerlink" title="2、验证"></a>2、验证</h3><p>​该阶段主要包括以下4个阶段，目的是为了验证Class文件的二进制内容对于虚拟机来说是否合法、安全。</p><ul><li><p><strong>文件格式验证</strong>，确保字节流符合Class文件格式的规范并且能被当前版本的JVM处理。</p><p>例如：验证魔数、验证主次版本号、检查常量tag标志等等</p></li><li><p><strong>元数据验证</strong>，主要进行语义校验，确保字节码的语义描述符合《Java语言规范》。</p><p>例如：该类是否有父类、是否错误继承了final类、是否实现了其父类或接口要求的所有方法等等</p></li><li><p><strong>字节码验证</strong>，主要通过数据流和控制流分析，确保程序语义合法且符合逻辑，以及确保类的方法体在运行时不会做出危害JVM安全的行为。</p><p>例如：验证类型转换是否合法、保证任意时刻栈帧的数据类型与指令代码序列都能配合工作（例如不会出现类似于“在栈帧放置了个int类型的数据，使用时却按照long类型来加载到本地变量表里”）等等</p></li><li><p><strong>符号引用验证</strong>，发生于虚拟机将符号引用转化为直接引用的时候（转换动作发生在解析阶段）。</p><p>例如：验证引用的类是否存在，验证引用的成员变量、类、方法是否能被当前类访问等等。</p></li></ul><p>​该验证的主要目的是为了确保解析行为能够正常执行，若无法通过符号引用验证，可能会抛出java.lang.IncompatibleClassChangeError异常的子类，如java.lang.IllegalAccessError、java.lang.NoSuchFieldError、java.lang.NoSuchMethodError等</p><h3 id="3、准备"><a href="#3、准备" class="headerlink" title="3、准备"></a>3、准备</h3><p>该阶段会正式为类成员变量（即static成员变量）分配内存，并将它们的初始值设置为默认值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static int a = 123;</span><br></pre></td></tr></table></figure><p>例如上述的类变量定义，在准备阶段后，a在内存中的值仍然为0，赋予123这个行为是在初始化<br>阶段才执行的</p><table><thead><tr><th>数据类型</th><th>零值</th><th>数据类型</th><th>零值</th></tr></thead><tbody><tr><td>int</td><td>0</td><td>boolean</td><td>false</td></tr><tr><td>long</td><td>0L</td><td>float</td><td>0.0f</td></tr><tr><td>short</td><td>(short)0</td><td>double</td><td>0.0d</td></tr><tr><td>char</td><td>‘\u0000’</td><td>reference</td><td>null</td></tr><tr><td>byte</td><td>(byte)0</td><td></td><td></td></tr></tbody></table><p>上面该表格为Java基本数据类型的零值，不过只要类字段的字段属性表中存在ConstantValue属性，那即使在准备阶段，该类变量也能初始化为指定的值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static final int a = 123;</span><br></pre></td></tr></table></figure><p>例如这次的a被final修饰符所修饰，变成一个常量，那在准备阶段完成时，它就不是0而是123了</p><h3 id="4、解析"><a href="#4、解析" class="headerlink" title="4、解析"></a>4、解析</h3><p>&amp;emsp;&amp;emsp;虚拟机会将常量池内的符号引用替换为直接引用，该解析主要针对的是类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用。</p><p>​虚拟机规范之中并没有规定解析阶段的具体发生时间，也就是说，在转换成直接引用后，可以触发校验阶段的符号引用验证，从这也能看出来类加载的各个阶段在实际进行时可能是交错执行的</p><h3 id="5、初始化"><a href="#5、初始化" class="headerlink" title="5、初始化"></a>5、初始化</h3><p>​初始化阶段会开始在内存中构造一个Class对象来表示该类，即执行类构造器<clinit>()方法的过程需注意的是，<clinit>()方法跟<init>()方法并不相同</init></clinit></clinit></p><ul><li><clinit>()方法中执行的是对所有类变量的赋值动作和静态语句块(static{}块)中的语句合并操作，并且编译器收集的顺序是由语句在源文件中出现的顺序决定的</clinit></li><li>虚拟机会确保先执行父类的<clinit>()方法，因此第一个被执行的类肯定是java.lang.Object，并且父类中定义的静态语句块要优先于子类的变量赋值操作</clinit></li><li>如果一个类中没有static语句块，也没有对类变量的赋值操作，那该类就不会生成<clinit>()方法</clinit></li><li>接口中不能使用静态代码块，但仍然有变量初始化的赋值操作，因此接口与类一样都会生成<clinit>()方法，但接口与类不同的是，执行接口的<clinit>()方法不需要先执行父接口的<clinit>()方法，因为只有当父接口中定义的变量被使用时，父接口才会被初始化。此外，接口的实现类在初始化时也一样不会执行接口的<clinit>()方法。</clinit></clinit></clinit></clinit></li><li>虚拟机会保证<clinit>()方法的执行在多线程中是安全的，如果多个线程去同时初始化一个类，那么只有一个线程会去执行该类的<clinit>()方法，其他线程都要阻塞等待</clinit></clinit></li></ul><h2 id="四、Java类加载器"><a href="#四、Java类加载器" class="headerlink" title="四、Java类加载器"></a>四、Java类加载器</h2><h3 id="1、含义"><a href="#1、含义" class="headerlink" title="1、含义"></a>1、含义</h3><p>​类加载器（class loader）是用来将Java类加载到虚拟机中的代码模块，加载一个Class文件首先需要获取该Class的二进制字节流，这个过程可以通过自定义类加载器来实现，从而可以通过多种灵活的途径获取Class的二进制字节流。</p><h3 id="2、确定唯一性"><a href="#2、确定唯一性" class="headerlink" title="2、确定唯一性"></a>2、确定唯一性</h3><p>​每个加载器都有各自独立的类名称空间，一个类的唯一性要通过其类加载器来确定。判断两个类是否相等，只有这两个类是由同一个类加载器加载的前提下才有意义，否则，即使两个类来自于同一个Class文件，被同一个虚拟机加载，只要加载它们的类加载器不同，那这两个类就不相同</p><h3 id="3、类加载器的主要类型"><a href="#3、类加载器的主要类型" class="headerlink" title="3、类加载器的主要类型"></a>3、类加载器的主要类型</h3><ul><li>启动类加载器（Bootstrap ClassLoader）<br>该加载器使用C++语言实现，是虚拟机自身的一部分，主要作用是加载<JAVA_HOME>\lib目录中的系统类库（如.rt.jar）</JAVA_HOME></li><li>扩展类加载器（Extension ClassLoader）<br>该加载器由sun.misc.Launcher$ExtClassLoader实现，负责加载<JAVA_HOME>\lib\ext目录中的，或者被java.ext.dirs系统变量所指定的路径中的所有类库</JAVA_HOME></li><li>应用程序类加载器（Application ClassLoader）<br>该加载器由sun.misc.Launcher$AppClassLoader实现，负责加载用户类路径（ClassPath）上所指定的类库，若应用程序没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器</li></ul><h3 id="4、双亲委派模型"><a href="#4、双亲委派模型" class="headerlink" title="4、双亲委派模型"></a>4、双亲委派模型</h3><p><img src="/2019/09/17/jvm-5/2.png" alt="2.png"></p><div align="center" style="font-size:12px">图5-2 双亲委派模型</div><p>​双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应该有自己的父类加载器。这里类加载器之间的父子关系一般不会以继承的关系来实现，而是用组合关系来复用父类加载器的代码</p><p>​每个类加载器都有自己的加载缓存，当一个类被加载后就会放入缓存，等下次加载时会直接从缓存中返回。</p><p>​工作流程：当一个类加载器去加载一个Class时，它会先委派自己的父类加载器去加载，每层都是这样，因此所有的加载器请求最终都应该传到顶层的启动类加载器中，只有父类加载器无法加载时，子类才会尝试自己去加载，并将其放进自己的缓存中。</p><p>​因此，加载过程可以看成自底向上检查类是否已经加载，然后自顶向下加载类，如下图所示。</p><p><img src="/2019/09/17/jvm-5/clipboard.png" alt="img"></p><div align="center" style="font-size:12px">图5-3 双亲委派模型的加载过程</div><p>​好处：双亲委派模型可以保证重要的系统Class始终由启动类加载器加载，确保Java运行环境的稳定性和正确性，避免用户自己编写的类动态替换 Java 的一些核心类（比如 String类）同时也避免了重复加载，因为 JVM 中区分不同类，不仅仅是根据类名，相同的 class 文件被不同的 ClassLoader 加载就是不同的两个类，如果相互转型的话会抛java.lang.ClassCaseException</p><p>参考自：<br><a href="https://www.cnblogs.com/jqctop1/">https://www.cnblogs.com/jqctop1/</a><br><a href="https://www.cnblogs.com/bokeyuanlongbin/p/9071629.html">https://www.cnblogs.com/bokeyuanlongbin/p/9071629.html</a><br>《深入理解Java虚拟机》</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>四、class文件的文件头</title>
      <link href="/2019/09/16/jvm-4/"/>
      <url>/2019/09/16/jvm-4/</url>
      
        <content type="html"><![CDATA[<h4 id="1、魔数（Magic-Number）"><a href="#1、魔数（Magic-Number）" class="headerlink" title="1、魔数（Magic Number）"></a>1、魔数（Magic Number）</h4><p>​前4个字节被称之为魔数，用于确定该文件是否为一个能被虚拟机接受的class文件</p><p>​class文件的魔数为0xCAFEBABE（咖啡宝贝）</p><h4 id="2、文件版本（Version）"><a href="#2、文件版本（Version）" class="headerlink" title="2、文件版本（Version）"></a>2、文件版本（Version）</h4><p>​第5、6个字节为次版本号，第7、8个字节为主版本号</p><p><img src="/2019/09/16/jvm-4/clipboard.png" alt="img"></p><p>​下图为class文件版本号</p><p><img src="/2019/09/16/jvm-4/clipboard-1613627011116.png" alt="img"></p><h4 id="3、常量池（Constant-Pool）"><a href="#3、常量池（Constant-Pool）" class="headerlink" title="3、常量池（Constant Pool）"></a>3、常量池（Constant Pool）</h4><p>​常量池入口，常量池主要存放字面量和符号引用</p><p>​字面量：比较接近于Java语言层面中的常量概念，如文本字符串、申明为final的常量值等</p><p>​符号引用：比较接近于编译原理方面的概念，主要包括类和接口的全限定名、字段的名称与描述符、方法的名称和描述符</p><p>​常量池分析：<a href="https://blog.csdn.net/gcw1024/article/details/51026840">https://blog.csdn.net/gcw1024/article/details/51026840</a></p><h4 id="4、访问标志（Access-Flags）"><a href="#4、访问标志（Access-Flags）" class="headerlink" title="4、访问标志（Access Flags）"></a>4、访问标志（Access Flags）</h4><p>​紧接着的两个字节表示访问标志，例如该class文件是类还是接口、是否是public、是否是abstract等等</p><h4 id="5、索引（Index）"><a href="#5、索引（Index）" class="headerlink" title="5、索引（Index）"></a>5、索引（Index）</h4><p>​类索引、父类索引、接口索引集合，三个都是u2（2个字节的无符号数）类型，这三项数据共同确定一个类的继承关系</p><h4 id="6、字段表集合（Field-Info）"><a href="#6、字段表集合（Field-Info）" class="headerlink" title="6、字段表集合（Field Info）"></a>6、字段表集合（Field Info）</h4><p>​字段表，用于描述接口或者类中声明的变量，例如作用域（public、private……）、是实例变量还是类变量（static）、可变性（final）、并发可见性（volatile）、字段数据类型（基本类型、对象、数组）。</p><p>​字段包括类级变量以及实例级变量，但不包括方法内部声明的局部变量</p><h4 id="7、方法表集合"><a href="#7、方法表集合" class="headerlink" title="7、方法表集合"></a>7、方法表集合</h4><p>​Class文件存储格式中对方法的描述和字段表几乎一致</p><p>​在Java语言中，要重载一个方法，除了要跟原方法具有相同的简单名称外，还必须要有一个与原方法不同的特征签名，特征签名就是一个方法中各个参数在常量池中的字段符号的集合，也就是因为返回值不会包含在特征签名中，因此Java语言里面是无法仅仅依靠返回值的不同来进行方法重载。</p><p>​但在Class文件中，特征签名的范围要更大些，只要描述符不是完全一致就可以共存，就是说如果两个方法有相同的名称和特征签名，但返回值不同，那么它们还是可以合法共存于同一Class文件当中</p><h4 id="8、属性表集合"><a href="#8、属性表集合" class="headerlink" title="8、属性表集合"></a>8、属性表集合</h4><p>​在Class文件、字段表、方发表都可以携带自己的属性表集合</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>三、Java垃圾收集器和内存分配策略</title>
      <link href="/2019/09/15/jvm-3/"/>
      <url>/2019/09/15/jvm-3/</url>
      
        <content type="html"><![CDATA[<h3 id="一、回收机制算法"><a href="#一、回收机制算法" class="headerlink" title="一、回收机制算法"></a>一、回收机制算法</h3><h4 id="1、引用计数算法"><a href="#1、引用计数算法" class="headerlink" title="1、引用计数算法"></a>1、引用计数算法</h4><p>&amp;emsp;&amp;emsp;概念：给对象添加一个引用计数器，每当对象被引用一次，计数器就加1， 当引用失效时，计数器值减1，当计数器为0时，则表示该对象可以被回收<br>&amp;emsp;&amp;emsp;结果：没被主流采用，因为两个对象相互引用的话，会造成无法回收的死循环</p><h4 id="2、可达性算法"><a href="#2、可达性算法" class="headerlink" title="2、可达性算法"></a>2、可达性算法</h4><p>​概念：从GC Roots作为起点开始搜索，当一个对象到GC Roots没有任何引用链相连，即该对象到GC Roots不可达时，该对象便可以被GC回收。</p><p>​所谓“GC roots”，或者说tracing GC的“根集合”，就是一组必须活跃的引用。</p><p>​GC Roots的对象：</p><p>​<strong>① 虚拟机栈（栈帧中的本地变量表）中引用的对象</strong>，例如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等</p><p>​<strong>② 方法区中静态属性引用的对象</strong>，例如Java类的引用类型静态变量</p><p>​<strong>③ 方法区中常量引用的对象</strong>，例如字符串常量池里的引用</p><p>​<strong>④ 本地方法栈中JNI（即一般说的Native方法）引用的对象</strong></p><p>​<strong>⑤ JVM内部的引用</strong>，例如基本数据类型对应的Class对象、一些常驻的异常对象（例如NullPotinException、OutOfMemoryError）等，还有系统类加载器</p><p>​<strong>⑥ 所有被同步锁（synchronized关键字）持有的对象</strong></p><p>​<strong>⑦ 把反应JVM内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等</strong></p><p>​除了这些固定的GC Roots集合外，根据用户所选用的垃圾收集器以及当前回收的内存区域不同，还可以有其他对象临时性地加入，共同构成完整GC Roots集合。</p><blockquote><p>GC Roots详解：<a href="https://www.zhihu.com/question/53613423/answer/135743258">https://www.zhihu.com/question/53613423/answer/135743258</a></p></blockquote><h3 id="二、Java的四种引用"><a href="#二、Java的四种引用" class="headerlink" title="二、Java的四种引用"></a>二、Java的四种引用</h3><ol><li>强引用：类似于A a &#x3D; new A()这类引用，只要强引用还存在，GC永远不会回收这类对象的内存</li><li>软引用：系统将要发生内存溢出异常之前，GC会将这类对象回收</li><li>弱引用：每当GC工作时，无论当前内存是否足够，这类对象都会被回收</li><li>虚引用：最弱的引用，和没有引用差不多，并且随时可能被回收。为一个对象设置虚引用关联的唯一目的就是能在这个对象被GC回收时收到一个系统通知</li></ol><blockquote><p>JDK1.2版之后提供了SoftReference类来实现软引用、WeakReference类实现弱引用、PhantomReference类实现虚引用</p></blockquote><h3 id="三、存活依据"><a href="#三、存活依据" class="headerlink" title="三、存活依据"></a>三、存活依据</h3><ol><li>进行可达性算法后发现并没有与GC Roots相连接的引用链，会被第一次标记并进行一次筛选</li><li>若对象没有覆盖finalize()方法或者finalize()方法已被虚拟机调用过，则会被视为“没有必要执行”</li><li>若该对象被判断为有必要执行finalize()方法，则该对象会被放置于名为F-Queue（即将回收）的队列中，等待执行finalize()方法</li><li>稍后GC会对F-Queue队列中的对象进行第二次小规模标记，倘若对象没在finalize()方法中重新连上GC Roots的引用链，那它就会被回收</li></ol><blockquote><p>注意：任何一个对象的finalize()方法都只会被调用一次，第一次要被回收时系统会去自动调用，可以看成是一次自救</p></blockquote><h3 id="四、垃圾收集算法"><a href="#四、垃圾收集算法" class="headerlink" title="四、垃圾收集算法"></a>四、垃圾收集算法</h3><h4 id="1、标记-清除算法"><a href="#1、标记-清除算法" class="headerlink" title="1、标记-清除算法"></a>1、标记-清除算法</h4><p>​首先标记出所有需要回收的对象，标记完成后再统一回收所有被标记的对象</p><p>​它是最基础的收集算法，主要不足有两个，一是标记和清理的效率都不高，另一个是会产生大量不连续的内存碎片</p><h4 id="2、复制算法"><a href="#2、复制算法" class="headerlink" title="2、复制算法"></a>2、复制算法</h4><p>​将内存分为大小相等的两部分，每次只使用其中一部分，倘若将这两部分看做A和B，则当A内存用完时，就会将存活对象复制到B内存上，再把A内存一次性全部清理掉。</p><p>​优点：每次都是对整个半区进行内存回收，不会出现内存碎片的情况</p><p>​缺点：可用内存只剩下原来的一半，代价太高了</p><blockquote><p>现在的商用JVM大多都优先采用这种收集算法去回收新生代，而由于新生代中的对象在一般场景下有98%熬不过第一轮收集，因此并不需要按照1：1的比例来划分新生代的内存空间</p></blockquote><h4 id="3、标记-整理算法"><a href="#3、标记-整理算法" class="headerlink" title="3、标记-整理算法"></a>3、标记-整理算法</h4><p>​标记过程跟“标记-清除算法”一样，但标记后会将所有存活对象向着同一端移动，然后直接清理掉端边界以外的内存</p><blockquote><p>HotSpot虚拟机中关注吞吐量的Parallel、Scavenge收集器是基于标记-整理算法的，而关注延迟的CMS收集器则是基于标记-清除算法的</p></blockquote><h4 id="4、分代算法"><a href="#4、分代算法" class="headerlink" title="4、分代算法"></a>4、分代算法</h4><p>&amp;emsp;&amp;emsp;根据对象存活周期的不同将内存分为好几块，一般是将Java堆分为新生代和年老代，再根据各自年代的特点去使用不同的收集算法</p><h3 id="五、垃圾收集器"><a href="#五、垃圾收集器" class="headerlink" title="五、垃圾收集器"></a>五、垃圾收集器</h3><p>​衡量垃圾收集器的三项最重要的指标是：内存占用（Footprint）、吞吐量（Throughput）和延迟（Latency），三者共同构成一个“不可能三角”。</p><p><img src="/2019/09/15/jvm-3/clipboard.png" alt="img"></p><h4 id="1、Serial收集器"><a href="#1、Serial收集器" class="headerlink" title="1、Serial收集器"></a>1、Serial收集器</h4><p>​新生代GC，单线程，采用复制算法，进行垃圾收集时会“Stop The World”。</p><p>​下图为Serial&#x2F;Serial Old收集器运行示意图</p><p><img src="/2019/09/15/jvm-3/clipboard-1613626750470.png" alt="img"></p><h4 id="2、ParNew收集器"><a href="#2、ParNew收集器" class="headerlink" title="2、ParNew收集器"></a>2、ParNew收集器</h4><p>​新生代GC，Serial的多线程版本，一样采用复制算法，一样会STW</p><p>​下图为ParNew&#x2F;Serial Old收集器运行示意图</p><p><img src="/2019/09/15/jvm-3/clipboard-1613626758491.png" alt="img"></p><h4 id="3、Parallel-Scavenge"><a href="#3、Parallel-Scavenge" class="headerlink" title="3、Parallel Scavenge"></a>3、Parallel Scavenge</h4><p>​新生代GC，多线程，采用标记-复制算法，它的目标是达成一个可控的吞吐量</p><p>​下图为Parallel Scavenge&#x2F;Parallel Old收集器运行示意图</p><p><img src="/2019/09/15/jvm-3/clipboard-1613626765685.png" alt="img"></p><h4 id="4、Serial-Old收集器"><a href="#4、Serial-Old收集器" class="headerlink" title="4、Serial Old收集器"></a>4、Serial Old收集器</h4><p>​老年代GC，单线程，采用标记-整理算法，可作为CMS收集器的后备预案</p><h4 id="5、Parallel-Old收集器"><a href="#5、Parallel-Old收集器" class="headerlink" title="5、Parallel Old收集器"></a>5、Parallel Old收集器</h4><p>​老年代GC，多线程，采用标记-整理算法，JDK1.6时才开始提供，用来替代Serial Old</p><h4 id="6、CMS收集器"><a href="#6、CMS收集器" class="headerlink" title="6、CMS收集器"></a>6、CMS收集器</h4><p>​老年代GC，并发收集，采用标记-清除算法，以获取最短停顿为目的，但需要更多内存。</p><p>​CMS运行过程有以下四个步骤</p><ul><li><ul><li><ol><li>初始标记：仅仅标记下GC Roots能直接关联到的对象，速度很快，需要STW</li><li>并发标记：进行GC Roots Tracing的过程，整个CMS处理过程中耗时最长</li><li>重新标记：为了修正并发标记期间因用户程序继续运行而导致标记变动的那一部分对象的标记记录，这个阶段的停顿时间通常会比初始标记阶段长一些，但也远比并发标记阶段的时间短，需要STW</li><li>并发清除：清理删除掉标记阶段判断的已死对象，不需要移动存活对象，可与用户线程同时并发。</li></ol></li></ul></li></ul><p>​下图为CMS收集器运行示意图</p><p><img src="/2019/09/15/jvm-3/clipboard-1613626788588.png" alt="img"></p><h4 id="7、G1收集器"><a href="#7、G1收集器" class="headerlink" title="7、G1收集器"></a>7、G1收集器</h4><p>​老年代+新生代GC，能并行与并发，采用分代收集算法，可实现可预测的停顿。</p><p>​它是面向堆内存任何部分来组成回收集（Collection Set，一般简称CSet）进行回收，其衡量标准不再是它属于哪个分代，而是哪块内存中存放的垃圾数量最多、回收收益最大，这就是G1收集器的Mixed GC模式。</p><p>​其运行过程有以下四个步骤：</p><ul><li><ul><li><ol><li>初始标记：仅仅标记下GC Roots能直接关联到的对象，速度很快，需要STW</li><li>并发标记：进行GC Roots Tracing的过程，递归扫描整个堆里的对象图，找出要回收的对象，并且扫描完成后还要重新处理SATB记录下的并发时有引用变动的对象。</li><li>最终标记：对用户线程做一个短暂的暂停，用于处理并发阶段结束后仍遗留下来的最后那少量的SATB记录</li><li>筛选回收：更新Region的统计数据，对各个Region的回收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划</li></ol></li></ul></li></ul><p>​除了并发标记外，其他三个阶段都需要STW</p><p>​下图为G1收集器运行示意图</p><p><img src="/2019/09/15/jvm-3/clipboard-1613626867386.png" alt="img"></p><blockquote><p>关于GC收集器的详细内容可前往：<a href="https://www.cnblogs.com/cxxjohnson/p/8625713.html">https://www.cnblogs.com/cxxjohnson/p/8625713.html</a></p></blockquote><h4 id="8、并发标记阶段如何保证收集线程与用户线程的互不干扰？"><a href="#8、并发标记阶段如何保证收集线程与用户线程的互不干扰？" class="headerlink" title="8、并发标记阶段如何保证收集线程与用户线程的互不干扰？"></a>8、并发标记阶段如何保证收集线程与用户线程的互不干扰？</h4><p>​CMS收集器采用增量更新算法来实现，而G1收集器则通过原始快照（SATB）算法来实现。</p><p>​STAB全称为snapshot-at-the-beginning，其目的是了维持并发GC的正确性。GC的正确性是保证存活的对象不被回收，换句话来说就是保证回收的都是垃圾。</p><h3 id="六、内存分配和回收策略"><a href="#六、内存分配和回收策略" class="headerlink" title="六、内存分配和回收策略"></a>六、内存分配和回收策略</h3><h4 id="1-对象优先在新生代的Eden区分配"><a href="#1-对象优先在新生代的Eden区分配" class="headerlink" title="1. 对象优先在新生代的Eden区分配"></a>1. 对象优先在新生代的Eden区分配</h4><p>​当Eden区没有足够空间进行分配时，JVM会发起一次Minor GC。</p><h4 id="2-大对象会直接进入老年代"><a href="#2-大对象会直接进入老年代" class="headerlink" title="2. 大对象会直接进入老年代"></a>2. 大对象会直接进入老年代</h4><p>&amp;emsp;&amp;emsp;-XX:PretenureSizeThreshold（可设置大于该参数的直接分配到老年代）</p><h4 id="3-长期存活对象将进入老年代"><a href="#3-长期存活对象将进入老年代" class="headerlink" title="3. 长期存活对象将进入老年代"></a>3. 长期存活对象将进入老年代</h4><p>​对于Survivor区中的对象，每经历过一次Minor GC，相应年龄就会增加一岁</p><p>​-XX:MaxTenuringThreshold（一般默认为15，大于该参数的会被晋升到老年代）</p><h4 id="4-动态对象年龄判定"><a href="#4-动态对象年龄判定" class="headerlink" title="4. 动态对象年龄判定"></a>4. 动态对象年龄判定</h4><p>&amp;emsp;&amp;emsp;其实不一定要年龄大于上面那个参数才能晋升老年代，只要在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，那么大于或等于该年龄的对象都能直接进入老年代</p><h4 id="5-空间分配担保"><a href="#5-空间分配担保" class="headerlink" title="5. 空间分配担保"></a>5. 空间分配担保</h4><p>&amp;emsp;&amp;emsp;在发生Minor GC之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象大小总和，若该条件成立，才能放心去Minor GC，若不成立，则虚拟机会查看HandlePromotionFailure设置值是否允许担保失败，若允许，则会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，若大于，才尝试去进行一次Minor GC，并且该Minor<br>GC还存在风险；倘若小于，或HandlePromotionFailure设置不允许冒险，那就应该改为进行一次Full GC（为了避免Full GC过多，一般该参数会设置为打开状态）<br>&amp;emsp;&amp;emsp;在JDK 6 Update 24之后，简化为发生Minor GC前检查老年代最大可用的连续空间是否大于新生代所有对象总大小或者历次晋升的平均大小，若大于则Minor GC，否则就Full  GC</p><h3 id="七、补充部分"><a href="#七、补充部分" class="headerlink" title="七、补充部分"></a>七、补充部分</h3><p>Minor GC、Major GC、Full GC之间的区别：<a href="https://www.cnblogs.com/tuhooo/p/7508503.html">https://www.cnblogs.com/tuhooo/p/7508503.html</a></p><p>GC算法和内存分配策略详细：<a href="https://crowhawk.github.io/2017/08/10/jvm_2/#hotspot%E7%9A%84%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0">https://crowhawk.github.io/2017/08/10/jvm_2&#x2F;#hotspot%E7%9A%84%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二、Java对象的创建、内存布局和访问</title>
      <link href="/2019/09/11/jvm-2/"/>
      <url>/2019/09/11/jvm-2/</url>
      
        <content type="html"><![CDATA[<h2 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h2><h3 id="1-使用指令创建对象"><a href="#1-使用指令创建对象" class="headerlink" title="1.使用指令创建对象"></a>1.使用指令创建对象</h3><p>​创建对象有多种方法，最常见的便是用New关键字创建对象，除此之外还可以使用反射机制（Class类的newInstance、使用Constructor类的newInstance方法）、Clone方法、反序列化等方式创建对象。</p><p>​由类加载器负责根据一个类的全限定名来读取此类的二进制字节流到JVM内部，并存储在运行时内存区的方法区，然后将其转换为一个与目标类型对应的java.lang.Class对象实例。</p><p>​</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span>, Serializable &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(Integer id)</span> &#123;<span class="built_in">this</span>.id = id;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;<span class="keyword">return</span> <span class="string">&quot;Student [id=&quot;</span> + id + <span class="string">&quot;]&quot;</span>;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用new关键字创建对象</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">stu1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">123</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用Class类的newInstance方法创建对象</span></span><br><span class="line">        <span class="comment">// 对应类必须具有无参构造方法，且只有这一种创建方式</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">stu2</span> <span class="operator">=</span> Student.class.newInstance();    </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用Constructor类的newInstance方法创建对象</span></span><br><span class="line">        Constructor&lt;Student&gt; constructor = Student.class</span><br><span class="line">                .getConstructor(Integer.class);   <span class="comment">// 调用有参构造方法</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">stu3</span> <span class="operator">=</span> constructor.newInstance(<span class="number">123</span>);   </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用Clone方法创建对象</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">stu4</span> <span class="operator">=</span> (Student) stu3.clone();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用(反)序列化机制创建对象</span></span><br><span class="line">        <span class="comment">// 写对象</span></span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">output</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;student.bin&quot;</span>));</span><br><span class="line">        output.writeObject(stu4);</span><br><span class="line">        output.close();</span><br><span class="line">        <span class="comment">// 读取对象</span></span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(</span><br><span class="line">                <span class="string">&quot;student.bin&quot;</span>));</span><br><span class="line">        <span class="type">Student</span> <span class="variable">stu5</span> <span class="operator">=</span> (Student) input.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-类加载检查"><a href="#2-类加载检查" class="headerlink" title="2.类加载检查"></a>2.类加载检查</h3><p>​根据new的参数检查能否在常量池中定位到一个类的符号引用（即类的带路径全名），并且检查这个符号引用代表的类是否已被加载、解析和初始化过，即该类有没被加载到方法区</p><h3 id="3-类加载"><a href="#3-类加载" class="headerlink" title="3.类加载"></a>3.类加载</h3><p>​若找不到相应的符号引用，即该类没被加载到方法区，则先进行类加载，若该类已被加载过，则继续</p><h3 id="4-分配内存"><a href="#4-分配内存" class="headerlink" title="4.分配内存"></a>4.分配内存</h3><ul><li>获取被加载类的对象所需内存大小（类加载后便可获知）</li><li>检查是否在TLAB中分配内存，若是则在TLAB中分配内存，否则就在Eden中分配内存（少数情况下也可能会直接分配给老年代中，例如大对象就直接进入老年代）</li></ul><h3 id="5-初始化零值"><a href="#5-初始化零值" class="headerlink" title="5.初始化零值"></a>5.初始化零值</h3><p>​将分配到的空间全部初始化为零值（不包括对象头），例如int&#x3D;0  string&#x3D;null boolean&#x3D;false，目前用户设定的初始值还未执行</p><h3 id="6-设置对象头信息"><a href="#6-设置对象头信息" class="headerlink" title="6.设置对象头信息"></a>6.设置对象头信息</h3><p>​初始化零值完成之后，虚拟机要对对象进行必要的设置，例如这个对象是那个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息，这些信息存放在对象头（Object Header）中。另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。</p><h3 id="7-执行init方法"><a href="#7-执行init方法" class="headerlink" title="7.执行init方法"></a>7.执行init方法</h3><p>​执行完上面的步骤之后，从虚拟机来看已经创建成功了，但对于Java程序而言还未真正完成，还需要调用init方法，把对象按照程序员的意愿去分配初始值，这样一个真正可用的对象才算创建完成</p><ul><li>如果对象是通过 clone() 方法创建的，那么 JVM 把原来被克隆的对象的实例变量的值拷贝到新对象中；</li><li>如果对象是通过 ObjectInputStream 类的 readObject() 方法创建的，那么 JVM 通过从输入流中读入的序列化数据来初始化那些非暂时性(non-transient)的实例变量；</li><li>如果实例变量在声明时被显式初始化，那么就把初始化值赋给实例变量，接着再执行构造方法。这是最常见的初始化对象的方式。</li></ul><h2 id="对于内存分配的两种方式"><a href="#对于内存分配的两种方式" class="headerlink" title="对于内存分配的两种方式"></a>对于内存分配的两种方式</h2><p><img src="/2019/09/11/jvm-2/1.png" alt="1.png"></p><div align="center" style="font-size:12px">图2-1 内存分配的两种方式</div><h2 id="对于内存分配的并发问题"><a href="#对于内存分配的并发问题" class="headerlink" title="对于内存分配的并发问题"></a>对于内存分配的并发问题</h2><h3 id="两种保障方式"><a href="#两种保障方式" class="headerlink" title="两种保障方式"></a>两种保障方式</h3><p>​在创建对象的时候有一个很重要的问题，就是线程安全，因为在实际开发过程中，创建对象是很频繁的事情，作为虚拟机来说，必须要保证线程是安全的，通常来讲，虚拟机采用两种方式来保证线程安全：</p><h4 id="1、CAS-失败重试"><a href="#1、CAS-失败重试" class="headerlink" title="1、CAS+失败重试"></a>1、CAS+失败重试</h4><p>CAS是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。</p><h4 id="2、TLAB"><a href="#2、TLAB" class="headerlink" title="2、TLAB"></a>2、TLAB</h4><p>为每一个线程预先在 Eden 区分配一块儿内存，JVM 在给线程中的对象分配内存时，首先在 TLAB 分配，当对象大于 TLAB 中的剩余内存或 TLAB 的内存已用尽时，再采用上述的 CAS 进行内存分配</p><h4 id="3、关于TLAB的补充说明"><a href="#3、关于TLAB的补充说明" class="headerlink" title="3、关于TLAB的补充说明"></a>3、关于TLAB的补充说明</h4><p>&amp;emsp;&amp;emsp;JVM在内存新生代Eden Space中开辟了一小块线程私有的区域，称作TLAB（Thread-local allocation buffer，线程本地分配缓存区）。默认设定为占用Eden Space的1%。在Java程序中很多对象都是小对象且用过即丢，它们不存在线程共享也适合被快速GC，所以对于小对象通常JVM会优先分配在TLAB上，并且TLAB上的分配由于是线程私有所以没有锁开销。因此在实践中分配多个小对象的效率通常比分配一个大对象的效率要高。</p><p>&amp;emsp;&amp;emsp;也就是说，Java中每个线程都会有自己的缓冲区称作TLAB（Thread-local allocation buffer），每个TLAB都只有一个线程可以操作，TLAB结合bump-the-pointer技术可以实现快速的对象分配，而不需要任何的锁进行同步，也就是说，在对象分配的时候不用锁住整个堆，而只需要在自己的缓冲区分配即可。</p><h2 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h2><h3 id="1-对象头"><a href="#1-对象头" class="headerlink" title="1.对象头"></a>1.对象头</h3><p>​Hotspot 虚拟机的对象头包括两部分信息，第一部分用于存储对象自身的自身运行时数据（哈希码、GC 分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等等），这部分数据称为“Mark Word“；另一部分是Class对象的类型指针（Klass Pointer），即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。</p><p><img src="/2019/09/11/jvm-2/clipboard.png" alt="img"></p><div align="center" style="font-size:12px">图2-2 64位JVM对象结构描述</div><h3 id="2-实例数据"><a href="#2-实例数据" class="headerlink" title="2.实例数据"></a>2.实例数据</h3><p>&amp;emsp;&amp;emsp;实例数据部分是对象真正存储的有效信息，也是在程序中所定义的各种类型的字段内容。</p><h3 id="3-对齐填充"><a href="#3-对齐填充" class="headerlink" title="3.对齐填充"></a>3.对齐填充</h3><p>&amp;emsp;&amp;emsp;对齐填充部分不是必然存在的，也没有什么特别的含义，仅仅起占位作用。 因为 Hotspot 虚拟机的自动内存管理系统要求对象起始地址必须是8字节的整数倍，换句话说就是对象的大小必须是8字节的整数倍。而对象头部分正好是8字节的倍数（1倍或2倍），因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。</p><h2 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h2><p>&amp;emsp;&amp;emsp;建立对象就是为了使用对象，我们的 Java 程序通过栈上的 reference 数据来操作堆上的具体对象。对象的访问方式有虚拟机实现而定，目前主流的访问方式有两种。</p><h3 id="1-使用句柄"><a href="#1-使用句柄" class="headerlink" title="1.使用句柄"></a>1.使用句柄</h3><p>​如果使用句柄的话，那么 Java 堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息</p><p>​使用句柄的好处：reference 中存储的是稳定的句柄地址，在对象被移动时（GC时很普遍会移动对象）只会改变句柄中的实例数据指针，而 reference 本身不需要修改</p><p><img src="/2019/09/11/jvm-2/2.png" alt="2.png"></p><h3 id="2-使用直接指针"><a href="#2-使用直接指针" class="headerlink" title="2.使用直接指针"></a>2.使用直接指针</h3><p>​如果使用直接指针访问，那么 Java 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而栈帧中的 reference 存储的直接就是对象的地址</p><p>​使用直接指针的好处：访问速度快，它节省了一次指针定位的时间开销。</p><p>​HotSpot虚拟机主要就是使用这种方式进行对象访问，但从整个软件开发的范围来看，在各种语言、框架中使用句柄访问的情况也十分常见。</p><p> <img src="/2019/09/11/jvm-2/3.png" alt="3.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一、Java内存区域</title>
      <link href="/2019/09/10/jvm-1/"/>
      <url>/2019/09/10/jvm-1/</url>
      
        <content type="html"><![CDATA[<h2 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h2><p><img src="/2019/09/10/jvm-1/1.png" alt="image"></p><div align="center" style="font-size:12px">图1-1 运行时数据区域</div><h3 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h3><ol><li>Java堆是JVM所管理的内存中最大的一块，属于线程共享的内存</li><li>该内存的唯一目的就是存放对象实例，几乎所有的对象实例和数组都要在堆上分配内存</li><li>Java堆是垃圾收集器管理的主要区域，有时候也被称之为GC堆（Garbage Collected Heap）。大部分GC收集器是基于分代收集理论设计的，例如我们认为的Java堆分为新生代、老年代、永久代、Eden区、From、Survivor区、To Survivor区，但实际上这并非《Java虚拟机规范》中对Java堆的细致划分，只是一部分垃圾收集器的设计风格</li><li>将Java堆进一步细致划分只是为了更好地回收内存、更快地分配内存。在JDK9以后的G1收集器、CMS、ZGC等都不再采用分代收集设计模式。（不过对于目前主流的JDK8而言，还是采用的这种模式）</li><li>如果在堆中没由内存完成实例分配，并且堆也无法扩展时，会抛出OutOfMemoryError异常</li></ol><h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><ol><li>用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器（JIT）编译后的代码等数据，属于线程共享的内存</li><li>它与”永久代“并不等价，方法区是一种规范、标准，而永久代只是HotSpot垃圾收集器的一种实现，在JDK1.8后，永久代被从方法区中去掉，取而代之的是元空间，即JDK1.8方法区的具体实现方式是元数据。</li><li>永久代中的 class metadata 转移到了 native memory（本地内存，而不是虚拟机）；永久代中的 interned Strings 和 class static variables 转移到了 Java heap；永久代参数 （PermSize MaxPermSize） -&gt; 元空间参数（MetaspaceSize MaxMetaspaceSize）</li><li>在主流版本的JDK8中，字符串常量池、静态变量放在堆中，类的元数据则存放在基于本机物理内存的元空间中</li><li>当方法区无法满足内存分配时，会抛出OutOfMemoryError异常</li></ol><h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><ol><li>运行时常量池是方法区的一部分，属于线程共享的内存</li><li>Class文件常量池用于存放编译期间生成的各种字面量和符号引用，它会在类加载后进入方法区的运行时常量池中存放，一个类加载对应一个运行时常量池</li><li>运行时常量池相对于Class文件常量池来说具备动态性，除了预置的内容，在运行期间产生的新常量也能放入池中</li><li>作为方法区的一部分，当常量池无法再申请到内存时会报OutOfMemoryError异常</li><li>补充：<a href="https://blog.csdn.net/qq_41155436/article/details/106466770">https://blog.csdn.net/qq_41155436/article/details/106466770</a></li></ol><h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><ol><li>程序计数器是一块较小的内存空间，可看作是当前线程所执行的字节码的行号指示器，为线程切换提供保障，属于线程私有的内存</li><li>若线程正在执行一个Java方法，则计数器会记录正在执行的虚拟机字节码指令的地址，若执行的是Native方法，则该计数器为空（Undefined）</li><li>该区域是Java虚拟机规范中唯一一个没有规定任何OutOfMemoryError情况的区域，因为它只存储和维护下一个需执行的命令的地址，即使是死循环也不会让内存超限</li><li>程序计数器与线程调度：<a href="https://blog.csdn.net/leaf_0303/article/details/78953669">https://blog.csdn.net/leaf_0303/article/details/78953669</a></li></ol><h3 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h3><ol><li>虚拟机栈描述的是Java方法执行的内存模型，生命周期与线程相同，属于线程私有的内存</li><li>栈帧(Stack Frame)用于存储局部变量表、操作数栈、动态链接、方法出口等信息，每个方法从调用到执行完成的过程，都对应着一个栈帧在虚拟机栈中由入栈到出栈的过程</li><li>局部变量表存放了编译期可知的各种基本数据类型、对象引用和returnAddress(下一条字节码指令地址)类型，所需空间会在编译期间完成分配，以局部变量槽（Slot）来表示，除64位长度的long和double类型数据会占用两个变量槽外，其余数据类型只占用一个。局部变量表的大小取决于虚拟机实现的每个变量槽的大小。</li><li>该区域规定了两种异常状况，如果线程请求的栈深度大于虚拟机所允许的深度，则抛出StackOverflowError异常；若虚拟机栈动态扩展（大部分JVM允许扩展，也可设置不扩展）时无法申请到足够的内存，则抛出OutOfMemoryError异常</li><li>栈帧的详细分析：<a href="https://blog.csdn.net/u014296316/article/details/82668670">https://blog.csdn.net/u014296316/article/details/82668670</a></li></ol><h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><ol><li>本地方法栈于虚拟机栈所发挥的作用差不多，属于线程私有的内存</li><li>虚拟机栈为虚拟机执行Java方法服务，本地方法栈为虚拟机用到的Native方法服务</li><li>抛出异常于虚拟机栈一样，StackOverflowError异常和OutOfMemoryError异常</li><li>《Java虚拟机规范》对本地方法栈中方法使用的语言、使用方式与数据结构并没有任何强制性要求，因此具体的虚拟机可根据需要自由实现它，例如Hot-Spot虚拟机就直接把本地方法栈和虚拟机栈合二为一。</li></ol><h2 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h2><ol><li>直接内存既不是虚拟机运行时数据区的一部分，也不是《Java虚拟机规范》中定义的内存区域，它是Java堆外内存</li><li>在JDK1.4时引入的NIO类，就是使用Native函数直接分配堆外内存，然后通过一个存储在Java堆内的DirectByteBuffer对象作为这块内存的引用进行操作</li><li>本机直接内存的分配不会受到Java堆大小的限制，但它还是内存，仍然会受到本机总内存以及处理器寻址空间的限制，当服务器管理员在配置虚拟机参数时粗心大意，使得各个内存区域总和大于物理内存限制，就会导致动态扩展时出现OutOfMemoryError异常</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot项目中关于maven依赖冲突的BUG处理(搞了一天的BUG)</title>
      <link href="/2019/05/12/SpringBoot-1/"/>
      <url>/2019/05/12/SpringBoot-1/</url>
      
        <content type="html"><![CDATA[<h3 id="第一个BUG"><a href="#第一个BUG" class="headerlink" title="第一个BUG"></a>第一个BUG</h3><p>首先是原初之罪的BUG，出现了找不到Bean的情况</p><p><img src="/2019/05/12/SpringBoot-1/1.jpg" alt="d2e1a8ec8c959c5b8079cdd030f938f2.jpeg"></p><p><img src="/2019/05/12/SpringBoot-1/2.png" alt="bb5fc51a0ca7e3047a08f22768885e58.png"></p><p>中间是怎么解决的我忘记了，还引出一个新建的maven module没有配置<code>Sources Root</code>、<code>Test Sources Root</code>等相应文件夹，后面这个通过<code>Project Structure</code>的Modules设置和Module自身的<code>.imi</code>文件设置就能解决</p><h3 id="第二个BUG"><a href="#第二个BUG" class="headerlink" title="第二个BUG"></a>第二个BUG</h3><p>解决了这些后，又TM引出了一个BUG</p><p><img src="/2019/05/12/SpringBoot-1/3.jpg" alt="32f7aeaf6df06b606f7d856afb5c3a43.jpeg"></p><p>无论都导入不了<code>tk.mybatis.mapper.common.Mapper</code>包</p><p><img src="/2019/05/12/SpringBoot-1/4.png" alt="78c2033d6d8888c7b3449d8e79deccce.png"></p><p>搞了半天都没处理好的我，毅然决然地使用了暴力破除法，直接重建一个项目，再将这个项目的东西搬过去，然后就好了……</p><p><img src="/2019/05/12/SpringBoot-1/5.jpg" alt="6804a1bfd13a933e956ce57d118d655a.jpeg"></p><p>本以为这样终于结束了，因为到这里已经花掉我半天时间了</p><p>——但！是！</p><p><img src="/2019/05/12/SpringBoot-1/6.jpg" alt="b20c8506f2ee9d6a261b6e4604f94bf4.jpeg"></p><h3 id="第三个BUG"><a href="#第三个BUG" class="headerlink" title="第三个BUG"></a>第三个BUG</h3><p>这里又双叒叕冒出来一个BUG了</p><p><img src="/2019/05/12/SpringBoot-1/7.jpg" alt="9e90f455f45ebbed3c8139b41f1f110a.jpeg"></p><p><img src="/2019/05/12/SpringBoot-1/8.png" alt="bcd9aced33b70b25aba20f0aec0e4d12.png"></p><p><img src="/2019/05/12/SpringBoot-1/9.png" alt="0df1b442e2f7e6c593e4d1ac05bc4ad3.png"></p><p><img src="/2019/05/12/SpringBoot-1/10.png" alt="77dcd3abf10610a79d5833f9d84ac675.png"></p><p>查看了下出错的源代码，很明显的<code>NoSuchMethodError</code>，找不到对应方法，源代码也是干脆利落地给出了红色标注我当场就懵了，总不会是源代码自己出错吧，没理由啊，肯定是自己太菜了，哪里弄错了才对</p><p><img src="/2019/05/12/SpringBoot-1/11.png" alt="a4f69231210ab8cb51b1884d37802657.png"></p><p>于是我又继续埋头苦干，边自己捣鼓，边去群里询问<br>期间从某个学习群的群友那里得到了一个可能是导错包了的原因，然后我想错了，以为是项目对于maven仓库包的引用导入有问题，需要更新下什么的，就把整个maven本地仓库删掉再重加载，再把项目的<code>Libraries</code>引用全删了再重新用<code>mvn compile</code>指令加载回来</p><p>然后不出意外的——问题并没有得到解决<br>（理所当然的，因为问题根本就不是出在那里）</p><p><img src="/2019/05/12/SpringBoot-1/12.jpg" alt="b5d9abefeaed36b137494ee2e77ffc7f.jpeg"></p><p>最后发现是<code>pom.xml</code>配置文件里面的依赖冲突导致的，将其那段多余的冲突依赖删掉后就没事了</p><p><img src="/2019/05/12/SpringBoot-1/13.png" alt="c26f422bafc783c442ad6431774e7bf0.png"></p><p><img src="/2019/05/12/SpringBoot-1/14.png" alt="18a54ef3a379e6292ede09ed488574a6.png"></p><h3 id="处理依赖冲突的maven-helper插件"><a href="#处理依赖冲突的maven-helper插件" class="headerlink" title="处理依赖冲突的maven helper插件"></a>处理依赖冲突的maven helper插件</h3><p>最后有个群友推荐了IDEA的一个专门处理maven依赖冲突的插件，<code>maven helper</code>，下载好了后重启，即可使用</p><p><img src="/2019/05/12/SpringBoot-1/15.png" alt="e39647badb576da80b60668ba938554d.png"></p><p>重启后进入<code>pom.xml</code>配置文件内，可看到以下内容</p><p><img src="/2019/05/12/SpringBoot-1/16.png" alt="bd4b7cbf67899e520830843266f12890.png"></p><p>使用时，右键可以将用不到的版本<code>Exclude</code>掉，不过要解决问题大多没那么简单直接<code>Exclude</code>就能完事的，相关教程什么的可以去网上找，这里就不多说了</p><p><img src="/2019/05/12/SpringBoot-1/17.png" alt="4173b9cb6ffa4c081718e22073b9ac53.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> springboot </tag>
            
            <tag> bug </tag>
            
            <tag> maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Next主题从5.1版本升级到7.1的捣鼓</title>
      <link href="/2019/04/30/hexo-next-1/"/>
      <url>/2019/04/30/hexo-next-1/</url>
      
        <content type="html"><![CDATA[<h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>下载<a href="https://github.com/theme-next/hexo-theme-next/releases">Next最新主题</a>并将解压到themes目录下，旧版本的Next主题先保留着作个数据对照和参考，等到新版本完全配置完毕，再删了也不迟，下面我只简单说些我感受到的版本差异，还有一些美化优化设置</p><h3 id="设置头像"><a href="#设置头像" class="headerlink" title="设置头像"></a>设置头像</h3><p>我用5.1版本时，头像的设置要在hexo的主配置 <code>_config.yml</code> 文件下添加以下代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">avatar: 头像图片的url地址</span><br></pre></td></tr></table></figure><p>新版本已经将头像设置的功能集合到Next主题的 <code>_config.yml</code> 配置文件中，我将头像图片放在hexo&#x2F;source&#x2F;imges中，配置如下图所示</p><p><img src="/2019/04/30/hexo-next-1/1.png" alt="79770a270ccdee6e35e15a4310a67e17.png"></p><h3 id="设置网站logo"><a href="#设置网站logo" class="headerlink" title="设置网站logo"></a>设置网站logo</h3><p>该功能同样集合在Next主题的 <code>_config.yml</code> 配置文件中，将分割好的网站logo文件替换掉Next主题的images文件夹下的logo文件，总共有三个文件要替换，注意大小跟格式要匹配<br><img src="/2019/04/30/hexo-next-1/2.png" alt="a344338330914b1e5820102cc90ce633.png"></p><p>Next主题的 <code>_config.yml</code> 配置文件，搜关键词 <code>favicon</code> 即可找到对应网站logo设置<br><img src="/2019/04/30/hexo-next-1/3.png" alt="b2b2e3dffd06b7ef587e0281648241a1.png"></p><h3 id="设置阅读全文"><a href="#设置阅读全文" class="headerlink" title="设置阅读全文"></a>设置阅读全文</h3><p>在个人博客中，倘若文章显示全文，那在首页就长得没法看后面的文章了，所以我们要给他设置个预览效果<br>在Next主题的<code>_config.yml</code>配置文件中，搜索 <code>auto_excerpt</code> 并将其唤醒，enable的参数为是否唤醒，length的参数则为展示的高度<br><img src="/2019/04/30/hexo-next-1/4.png" alt="6cfa11ec7d69f33e313a109889dfba8d.png"></p><h3 id="设置搜索功能"><a href="#设置搜索功能" class="headerlink" title="设置搜索功能"></a>设置搜索功能</h3><ol><li>安装插件</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure><ol start="2"><li><p>设置hexo的主配置文件</p><p>在文件中添加以下代码</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 本地搜索</span><br><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">  limit: 10000</span><br></pre></td></tr></table></figure><ol start="3"><li><p>设置Next主题的配置文件</p><p> 配置文件中有集成该搜索功能，搜索 <code>local_search</code> 并将其enble设置为true即可启动</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">local_search:</span><br><span class="line">  enable: true</span><br><span class="line">  trigger: auto</span><br><span class="line">  top_n_per_article: 1</span><br><span class="line">  unescape: false</span><br></pre></td></tr></table></figure><h3 id="设置背景图片以及界面透明化美化"><a href="#设置背景图片以及界面透明化美化" class="headerlink" title="设置背景图片以及界面透明化美化"></a>设置背景图片以及界面透明化美化</h3><p>修改Next主题下的source&#x2F;css&#x2F;_custom中的 <code>custom.styl</code> 文件，注意此处的背景图片是放在hexo根目录下的source&#x2F;images&#x2F;</p><p><img src="/2019/04/30/hexo-next-1/5.png" alt="2ea71659e63e34af8ff9948ef6f76734.png"></p><p>不过用上述这种方法将透明度修改过后，会造成一个BUG——搜索框不再置顶，而是被其他模块挡住了</p><p><img src="/2019/04/30/hexo-next-1/6.png" alt="14b9a761e03b759fa969c4f6dcb99cd8.png"></p><p>这个我折腾了半天，想出了个简单粗暴的方法，直接在设置透明度时给它来个z-index:9999的属性，虽说这样能解决问题，但解决BUG的代码是引出另外的、不怎么明显的BUG</p><p><img src="/2019/04/30/hexo-next-1/7.png" alt="eedad09f12015c27d3d505f359be3ac2.png"></p><p><img src="/2019/04/30/hexo-next-1/8.png" alt="352e54834089b15f90c35ab9e5658c3a.png"></p><p>从上图可以看出，菜单栏与搜索框一同置顶了，所以高亮的颜色跟周围有所不同，并且搜索框也被透明化了，让人观看时的体验不是很舒服</p><p>不过在这时，我不久前求助的群里，有个群友说他曾经也遇到过这个透明化问题，但他的解决方法是将菜单栏单独设置成白色透明的背景色，这样就能避免跟搜索框产生冲突，我去试了一下，这个方法能完美解决上述问题，同时不会让搜索框透明化</p><p><img src="/2019/04/30/hexo-next-1/9.png" alt="a679f699ff4c894b5cbdc6dcf92b026f.png"></p><p><img src="/2019/04/30/hexo-next-1/10.png" alt="875078b396b0e1440134352e7be4134b.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>阿里云Centos7.4服务器配置jdk、tomcat、mysql教程</title>
      <link href="/2019/04/02/aliCloud_1/"/>
      <url>/2019/04/02/aliCloud_1/</url>
      
        <content type="html"><![CDATA[<h2 id="一-配置jdk1-8"><a href="#一-配置jdk1-8" class="headerlink" title="一.配置jdk1.8"></a>一.配置jdk1.8</h2><p> 这个没啥好说的，直接输入指令安装 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install java-1.8.0-openjdk.x86_64</span><br></pre></td></tr></table></figure><p>安装成功后会有Complete提示，并且可通过java -version查看当前版本</p><p><img src="/2019/04/02/aliCloud_1/2.png" alt="e3cb0c4c0f022237be7912d8784284e0.png"></p><h2 id="二-搭建tomcat8"><a href="#二-搭建tomcat8" class="headerlink" title="二.搭建tomcat8"></a>二.搭建tomcat8</h2><p> 用xftp工具与服务器连接后，将下载好的tomcat压缩包丢到&#x2F;usr&#x2F;local&#x2F;目录下，再使用Xshell工具，输入命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf apache-tomcat-8.5.39.tar.gz </span><br></pre></td></tr></table></figure><p> 解压到当前目录，并将文件名改为tomcat8，之后就能将压缩包删了<br><img src="/2019/04/02/aliCloud_1/3.png" alt="91eeef02156e8b32458011da02ecce6f.png"></p><p> 阿里云服务器设置开放8080端口</p><p><img src="/2019/04/02/aliCloud_1/4.png" alt="7e55bd3204e3a5afbf44ef2e497c2871.png"></p><p><img src="/2019/04/02/aliCloud_1/5.png" alt="11b852296833403174608a717949382b.png"></p><p> 防火墙开放8080端口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">开放端口：firewall-cmd --zone-public --add-port=8080/tcp --permanent</span><br><span class="line">重新加载：firewall-cmd --reload</span><br></pre></td></tr></table></figure><p><img src="/2019/04/02/aliCloud_1/6.png" alt="afca678e829636d9add04bcc2502eeec.png"></p><p> 启动tomcat测试</p><p><img src="/2019/04/02/aliCloud_1/7.png" alt="279ad7b102351a7d57d99ec3ea6bcbc1.png"></p><p><img src="/2019/04/02/aliCloud_1/8.png" alt="8180f63d54178a788d7519463d16a639.png"></p><p> 提高阿里云服务器部署的tomcat外界访问速度，以下为原文地址</p><p> <a href="https://blog.csdn.net/qq_40386113/article/details/84837881">https://blog.csdn.net/qq_40386113&#x2F;article&#x2F;details&#x2F;84837881</a></p><p><img src="/2019/04/02/aliCloud_1/9.png" alt="773c99f1fec5e1b34e741958fb90d966.png"></p><h2 id="三-mysql安装配置"><a href="#三-mysql安装配置" class="headerlink" title="三.mysql安装配置"></a>三.mysql安装配置</h2><p> 执行命令, 安装mysql</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install mysql-community-server</span><br></pre></td></tr></table></figure><p><img src="/2019/04/02/aliCloud_1/10.png" alt="c3e681f10fae02b14d6457061850f187.png"></p><p> 检查是否安装成功</p><p><img src="/2019/04/02/aliCloud_1/11.png" alt="f6464c8512f83e80f025952db182eccc.png"></p><p> 设置开机自动启动mysql，使用以下两个命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable mysqld</span><br><span class="line">systemctl list-unit-files | grep mysqld</span><br></pre></td></tr></table></figure><p> 查看是否设置成功</p><p><img src="/2019/04/02/aliCloud_1/12.png" alt="439b32303bbf837d43f4cd68a5c478ac.png"></p><p>启动mysql服务，并查看mysql服务是否已启动</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl start mysqld</span><br><span class="line">ps -ef|grep mysql</span><br></pre></td></tr></table></figure><p><img src="/2019/04/02/aliCloud_1/13.png" alt="d16b8773edb7b2777374d9a574088661.png"></p><p> 进行mysql的用户名、密码等信息进行配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql_secure_installation</span><br></pre></td></tr></table></figure><p><img src="/2019/04/02/aliCloud_1/14.png" alt="04a407fe51dd10627c11acd3ba551754.png"></p><p><img src="/2019/04/02/aliCloud_1/15.png" alt="8a238f144ba030e1ec44ce1d899080fd.png"></p><p> 启动mysql</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -uroot -p</span><br></pre></td></tr></table></figure><p><img src="/2019/04/02/aliCloud_1/16.png" alt="c0b70c501c48d48e8aa969f4ca509f49.png"></p><p> 防火墙开放3306端口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --zone-public --add-port=3306/tcp --permanent</span><br><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure><p><img src="/2019/04/02/aliCloud_1/17.png" alt="6851372672b8e250b33fa79fcf0ec75a.png"></p><p> 配置远程登录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grant all privileges on *.* to &#x27;root&#x27;@&#x27;%&#x27; identified by &#x27;root&#x27; with grant option;</span><br></pre></td></tr></table></figure><p> （指令意为将所有权限赋予给 root 用户，并允许其进行远程登录）</p><p> 红框部分填写的是访问远程访问root用户所使用的密码</p><p><img src="/2019/04/02/aliCloud_1/18.png" alt="c15ef91aed759f37a7c7305a49209b62.png"></p><p> 最后，用其他机子测试连接成功<br><img src="/2019/04/02/aliCloud_1/19.png" alt="e34677cd4d3984dfd506876f7ef97226.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 阿里云Centos </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
